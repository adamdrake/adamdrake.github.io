<!doctype html><html lang=en><head><meta charset=utf-8><meta name=mobile-web-app-capable content="yes"><meta name=viewport content="width=device-width,initial-scale=1"><title>On Schemas - Adam Drake</title><meta name=description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI, leadership, and building tech teams."><link rel="shortcut icon" href=https://adamdrake.com/static/favicon.ico><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=me href=https://github.com/adamdrake><link rel=stylesheet href=https://adamdrake.com/css/style.min.css crossorigin=anonymous media=screen><meta property="og:url" content="https://adamdrake.com/"><meta property="og:title" content="Adam Drake"><meta property="og:site_name" content="Adam Drake"><meta property="og:type" content="website"><meta property="og:description" content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI, leadership, and building tech teams."><meta property="og:image" content="/static/images/twitter-card.jpg"><meta name=twitter:title content="Adam Drake"><meta name=twitter:description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI, leadership, and building tech teams."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/static/images/twitter-card.jpg"></head><body><header><section><div class="header flex row"><div class="header__item flex row"><a id=site__name href=https://adamdrake.com/>Adam Drake</a></div><div class="flex row"><nav aria-label="page menu" class="flex row"><ul role=menubar class="flex row"><li role=none><a class=sidebar-nav-itemmenu__item href=/ title>Latest</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/about.html title>About</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/cases.html title>Case Studies</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/contact.html title>Contact</a></li><li role=none><a class="sidebar-nav-item activemenu__item" href=/posts.html title=Posts>Posts</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/press.html title>Press</a></li><li><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button></li></ul></nav></div></div></section></header><main aria-role=main><section><ul id=feed__ul><li class="feed__li h-entry"><div class=feed__content><time class="hidden dt-published">2015-02-15 00:00:00 +0000 UTC</time><div class="flex properties__row"><div rel=author class="flex left p-author h-card"><img class=u-photo src=https://adamdrake.com/static/images/adam_drake_240.jpg alt="Adam Drake" id=author-img><div><p rel=me class=p-name id=author-name>Adam Drake</p><p class=properties>Feb 15, 2015</p></div></div><div class="flex right properties"></div></div><article class="md p-summary e-content"><h2 class=p-name>On Schemas</h2><h1 id=introduction class=anchor-link><a href=#introduction>Introduction</a></h1><p>Over the last few years, some people have come to see schemas of any type as a legacy hinderance which should generally be ignored, and much of the NoSQL fervor that gained momentum around 2010 was related to this. The promise was that not having schemas would set you free and that you would become more productive, agile, your application would be faster, and all kinds of other things. Some of this may have been true for web applications or APIs backed by a single data store, in a relatively small company or team, but it&rsquo;s an entirely different matter when talking about distributed data processing systems.</p><p>In reality, schemas serve a very necessary function when systems need to start talking to each other as schemas define a clear contract between systems. This allows for distributed data processing systems to grow in a reasonable way, reduces errors throughout the data pipeline, and can provide far more flexibility and development speed than if the messages between systems had no schema at all. Additionally, this is critical when you don&rsquo;t have complete knowledge of which consumers will actually be using your service. Whether you call it API documentation, service description, or you have a solid interface definition with Protocol Buffers or Avro, schemas are absolutely necessary for data in motion.</p><h1 id=everything-has-a-structure-anyway class=anchor-link><a href=#everything-has-a-structure-anyway>Everything has a structure anyway</a></h1><p>If you are pushing data between systems, in the vast majority of cases the data has some kind of structure. There are certain classes of unstructured data, like video, audio, or images, but typically at least the metadata about them is structured. Given this fact, when any two systems want to communicate they must be able to move the data around by speaking the same language, and this language is the schema.</p><p>If you don&rsquo;t have a schema on the message itself, what ends up happening is that the producer has the schema embedded implicitly in its codebase (in order to verify it&rsquo;s sending correct and complete messages) and the receiver of the message also has the schema implicitly embedded in its codebase (also to check for correctness and completeness). This is bad enough, but when other receivers are added the situation gets even worse as each receiver must implement its own implicit schema in the codebase. The result being that instead of simply making the schema explicit and shared among all senders and receivers, the schema is implicit and possibly inconsistent across the distributed system.</p><h1 id=enter-message-schemas class=anchor-link><a href=#enter-message-schemas>Enter message schemas</a></h1><p>When we talk about message schemas we are in a different context than a schema for a database table. The reason being that for applications that want to communicate with the database, each one must implement the schema (this part is the same) but in the case of databases there is often no simple ways to extend or modify the schema without disruption for clients. You could argue that views achieve this, but we are talking about the situation where the underlying table structure needs to change.</p><p>The interruptions to clients can be significant, but are often things like downtime of the database, or slowness due to changing fields in a table with lots of data, or other things. For example, consider the way that Percona, a high-performance and high-availability version of MySQL, addresses the problem of adding columns to tables (i.e., changing the schema) with the <a href=https://www.percona.com/doc/percona-toolkit/2.1/pt-online-schema-change.html>pt-online-schema-change</a> tool:</p><blockquote><p>pt-online-schema-change works by creating an empty copy of the table to alter, modifying it as desired, and then copying rows from the original table into the new table. When the copy is complete, it moves away the original table and replaces it with the new one. By default, it also drops the original table.</p></blockquote><p>There are additional concerns when the table you want to change contains foreign keys, but that&rsquo;s even more operationally complex. These difficulties with database schemas can be avoided in message schemas implemented with Protocol Buffers, Avro, and other message serialization formats. The reason for this is that with Protocol Buffers for example, when best practices are followed a producer can extend the schema with additional optional fields at any time, with no impact on the downstream consumers whatsoever. This is a huge difference, because adding a column to a database table can be a potentially dangerous process by comparison.</p><h1 id=schemas-and-distributed-systems class=anchor-link><a href=#schemas-and-distributed-systems>Schemas and distributed systems</a></h1><p>As systems grow larger, with more producers and consumers, protections on message correctness become even more important. There are just simply more ways to form an incorrect message than a correct one, and unless you want to implement a lot of this correctness checking by hand, and spend a lot of time sorting out errors due to malformed messages, it makes sense to have schemas on all messages. This line of reasoning is typically countered with the position that having schemas on messages will reduce flexibility for developers and cause dependencies. There are two reasons that the statement is incorrect.</p><p>First, if a producer is producing messages and a consumer is consuming those messages then that producer and consumer have a dependency regardless of whether or not there is a schema on the message. The two components simply cannot function properly without each other, so pretending there isn&rsquo;t some inherent dependency there can lead to poor design decisions, especially in systems with strong volume, frequency, or latency requirements.</p><p>Second, the flexibility argument shows a lack of understanding as the message schemas are different from schemas in a database. The reason for this is that, as mentioned, the message schemas can be easily extended as needed to support product goals and this extension can be done independently of other producers or consumers. Other producers can still produce with the same old schema and older consumers can still consume using the old version of the schema. Any new fields simply won&rsquo;t be accessible to the consumers until they update to use the new schema version.</p><h1 id=json-does-not-count class=anchor-link><a href=#json-does-not-count>JSON does not count</a></h1><p>There are many people who argue that having the messages in JSON format is good enough and even preferable to other formats as the message are human-readable. It is true that they are human readable, but I don&rsquo;t see that as a big enough benefit. The number of times your message are read by humans is absolutely dwarfed by how often they are processed by machines.</p><p>Additionally, JSON simply is not descriptive enough in terms of field types to provide a good definition of messages. Is that numeric field an integer or a float? Are you implementing a lot of checking on the producer or consumer to make sure the message fields are of the correct type, length, and so on? If so, your approach to schemas needs improvement. If you cannot ensure basic data quality and consistency, your distributed system will inevitably encounter more problems than necessary, and distributed data processing systems have enough complexity as it is.</p><h1 id=have-no-fear class=anchor-link><a href=#have-no-fear>Have no fear</a></h1><p>The bad reputation of schemas in the last years is very unfortunate as they are a critical components of any well-functioning distributed system. I have a general requirement when building distributed systems that all data in motion must have a schema, because the simple fact is that it has some structure when it is produced, and it lands somewhere with some structure, so having many components in between, each of which could possibly corrupt the data, doesn&rsquo;t make any sense. Without clear contracts between message producers and consumers, the implicit schemas in every codebase become unmanageable, error prone, and impossible to update effectively, leading to severe degradation in development speed and overall system quality and stability. This doesn&rsquo;t typically show up early in the development of a distributed system, or in small teams or codebases, or those with very few components, but since the complexity of a distributed system increases at a multiple much larger than the increase in components it becomes a critical problem.</p><p>Message schemas are not a bad thing (nor are database schemas when properly implemented) so use them wisely and reap the benefits of increased interoperability, stability, and extensibility of your distributed data processing system.</p><a class=hidden href=https://brid.gy/publish/mastodon></a><a class=hidden href=https://brid.gy/publish/twitter></a><a class=hidden href=https://fed.brid.gy/></a><data class=p-bridgy-omit-link value=false></data></article></div><div id=webmentions></div></li></ul></section></main><hr><footer class="flex col"><section class="footer-bio content"><p><strong>Adam Drake</strong> leads technical business transformations in global and multi-cultural environments. He has a passion for helping companies become more productive by improving internal leadership capabilities, and accelerating product development through technology and data architecture guidance. Adam has served as a White House Presidential Innovation Fellow and is an IEEE Senior Member.</p></section><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button><div class=social-icons><a rel=me href=https://github.com/adamdrake title=GitHub><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></body></html>
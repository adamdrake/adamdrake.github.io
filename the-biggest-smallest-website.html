<!doctype html><html lang=en><head><meta charset=utf-8><meta name=mobile-web-app-capable content="yes"><meta name=viewport content="width=device-width,initial-scale=1"><title>The biggest smallest website - Adam Drake</title><meta name=description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/crypto/data, leadership, and building tech teams."><link rel="shortcut icon" href=https://adamdrake.com/static/favicon.ico><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=me href=https://github.com/adamdrake><link rel=me href=https://twitter.com/aadrake><link rel=stylesheet href=https://adamdrake.com/css/style.min.css crossorigin=anonymous media=screen><meta property="og:url" content="https://adamdrake.com"><meta property="og:title" content="Adam Drake"><meta property="og:site_name" content="Adam Drake"><meta property="og:type" content="website"><meta property="og:description" content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/crypto/data, leadership, and building tech teams."><meta property="og:image" content="/static/images/twitter-card.jpg"><meta name=twitter:title content="Adam Drake"><meta name=twitter:description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/crypto/data, leadership, and building tech teams."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/static/images/twitter-card.jpg"></head><body><header><section><div class="header flex row"><div class="header__item flex row"><a id=site__name href=https://adamdrake.com>Adam Drake</a></div><div class="flex row"><nav aria-label="page menu" class="flex row"><ul role=menubar class="flex row"><li role=none><a class=sidebar-nav-itemmenu__item href=/ title>Latest</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/about.html title>About</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/cases.html title>Case Studies</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/contact.html title>Contact</a></li><li role=none><a class="sidebar-nav-item activemenu__item" href=/posts.html title=Posts>Posts</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/press.html title>Press</a></li><li><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button></li></ul></nav></div></div></section></header><main aria-role=main><section><ul id=feed__ul><li class="feed__li h-entry"><div class=feed__content><time class="hidden dt-published">2017-10-29 00:00:00 +0000 UTC</time><div class="flex properties__row"><div rel=author class="flex left p-author h-card hidden"><img class=u-photo src=https://adamdrake.com/static/images/adam_drake_240.jpg alt="Adam Drake" id=author-img><div><p rel=me class=p-name id=author-name>Adam Drake</p><p class=properties>Oct 29, 2017</p></div></div><div class="flex right properties"></div></div><article class="md p-summary e-content"><h1 class=p-name>The biggest smallest website</h1><h1 id=introduction class=anchor-link><a href=#introduction>Introduction</a></h1><p>I was surfing the web and, as is often the case, I stumbled upon a cool project: the <a href=https://github.com/diracdeltas/FastestWebsiteEver>FastestWebsiteEver</a>. It&rsquo;s &ldquo;the greatest website to ever fit in a single TCP packet.&rdquo;</p><p>I had a think about that for a minute, and checked out the actual site, and noticed that it&rsquo;s approximately 1130 bytes transferred. Now depending on how fresh you are on your <a href=https://en.wikipedia.org/wiki/OSI_model>OSI Model</a>, you might remember that there are 7 layers. The data that fits into a single transmissable unit in one layer may be too big for one of the other layers to transmit as a single unit, resulting in fragmentation and reassembly. I thought 1130 bytes sounded rather large for something guaranteed to fit into a single packet (although 1500 bytes is standard MTU for Ethernet), so I decided it might be fun to dig up the old RFCs and have a look at what the TCP and IP specifications say.</p><h1 id=tcp-and-ip-rfcs class=anchor-link><a href=#tcp-and-ip-rfcs>TCP and IP RFCs</a></h1><p>One of the original TCP/IP specs, RFC 879, has been updated by <a href=https://tools.ietf.org/html/rfc6691>RFC 6691</a>. In this RFC, we learn that:</p><blockquote><p>THE TCP MAXIMUM SEGMENT SIZE IS THE IP MAXIMUM DATAGRAM SIZE MINUS FORTY.</p></blockquote><p>Well, the maximum IP datagram size is 576 bytes, so we know that the maximum segment size (MSS) for TCP is 536 bytes. This leaves 20 bytes for minimal TCP headers, and 20 bytes for minimal IP headers. If we send an IP datagram of 536 bytes, we are guaranteed that the datagram (and the resulting TCP segment) will not be fragmented and will be delivered in a single unit.</p><p>Okay. Let&rsquo;s build a website that fits into 536 bytes!</p><h1 id=http-rfc class=anchor-link><a href=#http-rfc>HTTP RFC</a></h1><p>First, we don&rsquo;t need a full-blown HTTP server for this. We just need a TCP server that responds with a string of bytes containing the smallest valid HTTP response, and our website content, all of which has to be less than 536 bytes. We have to respond with a valid HTTP response, but what is that, exactly?</p><p>Well, <a href=https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html>RFC 2616</a> is pretty clear about the format of an HTTP response:</p><blockquote><p>Response = Status-Line ; Section 6.1</p><pre><code>                  *(( general-header        ; Section 4.5

                   | response-header        ; Section 6.2

                   | entity-header ) CRLF)  ; Section 7.1

                  CRLF

                  [ message-body ]          ; Section 7.2
</code></pre></blockquote><p>That means that the only required element is the the <em>Status-Line</em>.</p><blockquote><p>Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</p></blockquote><p>Easy enough. The smallest thing we could send as a response from our TCP server is <code>HTTP/1.1 200 OK\r\n</code>. That response string is 17 bytes, which cuts our available bytes for the message body down to 519 bytes. As a reminder of the accounting: we can send 576 bytes total in a single TCP segment, and we must reserve 20 for TCP header, 20 for IP header. This leaves us 536 bytes for everything else. We need another 17 bytes for the HTTP response, giving us 536-17=519 bytes.</p><h1 id=building-a-tcp-server class=anchor-link><a href=#building-a-tcp-server>Building a TCP server</a></h1><p>Writing a TCP server is pretty simple in many languages, but I chose to do it in Go.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;bufio&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ip</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>IPv4</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tcpaddr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>TCPAddr</span>{<span style=color:#a6e22e>IP</span>: <span style=color:#a6e22e>ip</span>, <span style=color:#a6e22e>Port</span>: <span style=color:#ae81ff>8080</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ln</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>ListenTCP</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>tcpaddr</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>httpResponse</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>&#34;HTTP/1.1 200 OK\r\n&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>AcceptTCP</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>SetNoDelay</span>(<span style=color:#66d9ef>true</span>) <span style=color:#75715e>// Silly windows are silly.  See Nagling.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>conn</span>).<span style=color:#a6e22e>ReadLine</span>()  <span style=color:#75715e>// This is used in the stdlib HTTP server
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>httpResponse</span>)
</span></span><span style=display:flex><span>        }()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Most of that is straightforward, but there is one small item which may seem unexpected: <code>conn.SetNoDelay(true)</code>. What&rsquo;s that about?</p><h2 id=nagling-an-aside class=anchor-link><a href=#nagling-an-aside>Nagling: an aside</a></h2><p>In the old days, before people knew how to write efficient networked applications (wait, is that not true anymore&mldr;?), it was sometimes the case that a TCP packet would need to be transmitted with a very small payload. As a pathological example, consider a payload of 1 byte. This would require at least 20 bytes for the IP header, and 20 bytes for the TCP header, just to send 1 byte of data. Since having 40 to 1 overhead for data transmission is bad, John Nagle decided it would be a good idea to batch the sending of TCP packets. Hence, we have <a href=https://en.wikipedia.org/wiki/Nagle%27s_algorithm>Nagle&rsquo;s Algorithm</a>.</p><p>The short version is that if you can fit more data into the TCP segment, wait and accumulate before sending anything. This prioritizes throughput over latency.</p><p>For our purposes, since we want the lowest latency and we are carefully constructing our TCP segment, we can disable Nagling on our TCP connections. This is accomplished in Go by setting <code>SetNoDelay(true)</code> on our connections as they come in.</p><h1 id=the-content class=anchor-link><a href=#the-content>The content</a></h1><p>Now that we have a working server that responds to TCP requests with a valid HTTP response, we can add some content using our remaining 519 bytes. Since 1 ASCII character is 1 byte, that doesn&rsquo;t leave us much to work with. It&rsquo;s not even 4 tweets worth of text (well, it&rsquo;s 1.85 tweets after the new limit rolls out). However, we can compress the content before we send it, allowing us to fit much more into the same 519 bytes!</p><p>The downside to using compression is that we have to tell the HTTP client about it. We&rsquo;ll need to add an encoding header to our HTTP response, which will take up some bytes. In the old days, it was possible to send raw DEFLATE encoded data to a browser and have it do the decoding by default, but those days are gone now.</p><p>We&rsquo;ll have to put our header on a new line, which means we will need to take two bytes for a <code>\r\n</code> in addition to the header itself. After our header, <code>Content-Encoding: deflate</code>, we also need an additional <code>\r\n</code> at the end of our HTTP response. In total, the ability to compress the response costs us another 29 bytes. Now we&rsquo;re down to 490 bytes for content, but it&rsquo;s for <em>compressed</em> content. Using DEFLATE, we can probably reduce the size by 50% after compression, so if we start with about 1000 bytes, we should be able to compress down to 490.</p><p>In the meantime however, here&rsquo;s the updated server with compression:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;bufio&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;bytes&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;compress/flate&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ip</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>IPv4</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tcpaddr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>TCPAddr</span>{<span style=color:#a6e22e>IP</span>: <span style=color:#a6e22e>ip</span>, <span style=color:#a6e22e>Port</span>: <span style=color:#ae81ff>8080</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ln</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>ListenTCP</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>tcpaddr</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>httpResponse</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>&#34;HTTP/1.1 200 OK\r\nContent-Encoding: deflate\r\n\r\n&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resp</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;Hello, world!&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>buf</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>zw</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flate</span>.<span style=color:#a6e22e>NewWriter</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>flate</span>.<span style=color:#a6e22e>BestCompression</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>zw</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#a6e22e>resp</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>zw</span>.<span style=color:#a6e22e>Close</span>()  <span style=color:#75715e>// In case buffers need to be flushed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>compressedBody</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>Next</span>(<span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>Len</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>AcceptTCP</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>SetNoDelay</span>(<span style=color:#66d9ef>true</span>) <span style=color:#75715e>// Silly windows are silly.  See Nagling.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>conn</span>).<span style=color:#a6e22e>ReadLine</span>()  <span style=color:#75715e>// This is used in the stdlib HTTP server
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Write</span>(append(<span style=color:#a6e22e>httpResponse</span>, <span style=color:#a6e22e>compressedBody</span><span style=color:#f92672>...</span>))
</span></span><span style=display:flex><span>        }()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=fin class=anchor-link><a href=#fin>Fin</a></h1><p>From that point, it&rsquo;s a matter of extending <code>resp</code> until you have the response body you want while still coming in under the 536 total bytes allowed for a single TCP segment. If you wanted to be extra careful, you could add an if statement to check that the length of <code>compressedBody</code> is less than 536 (the IP datagram body size limit), and exit the program if it isn&rsquo;t.</p><p>If you find any issues with the code above or notice something I misinterpreted about the RFCs, do contact me so I can update things.</p><p>If you want to see the biggest smallest site, you can visit it at <a href=https://tinysite.adamdrake.com>tinysite.adamdrake.com</a>.</p><p>Lastly, I also did a quick TCP server in Rust as well to see if the performance was any better than the Go version, but there wasn&rsquo;t a big difference in this case.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::io::{Read, Write};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::net::TcpListener;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> listener <span style=color:#f92672>=</span> TcpListener::bind(<span style=color:#e6db74>&#34;127.0.0.1:9123&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;listening started, ready to accept&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> stream <span style=color:#66d9ef>in</span> listener.incoming() {
</span></span><span style=display:flex><span>        thread::spawn(<span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> stream <span style=color:#f92672>=</span> stream.unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> stream.read(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> [<span style=color:#ae81ff>0</span>; <span style=color:#ae81ff>128</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            stream.write(<span style=color:#e6db74>b&#34;Hello World</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>).unwrap();
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><a class=hidden href=https://brid.gy/publish/mastodon></a>
<a class=hidden href=https://brid.gy/publish/twitter></a>
<a class=hidden href=https://fed.brid.gy/></a>
<data class=p-bridgy-omit-link value=false></data></article></div><div id=webmentions></div></li></ul></section></main><hr><footer class="flex col"><section class="footer-bio content"><p><strong>Adam Drake</strong> leads technical business transformations in global and multi-cultural environments. He has a passion for helping companies become more productive by improving internal leadership capabilities, and accelerating product development through technology and data architecture guidance. Adam has served as a White House Presidential Innovation Fellow and is an IEEE Senior Member.</p></section><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button><div class=social-icons><a rel=me href=https://github.com/adamdrake title=GitHub><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a rel=me href=https://linkedin.com/in/aadrake title=LinkedIn><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a><a rel=me href=https://twitter.com/aadrake title=Twitter><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></footer></body></html>
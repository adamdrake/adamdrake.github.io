<!doctype html><html lang=en><head><meta charset=utf-8><meta name=mobile-web-app-capable content="yes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Are your Functions Total? - Adam Drake</title><meta name=description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/data, leadership, and building tech teams."><link rel="shortcut icon" href=https://adamdrake.com/static/favicon.ico><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=me href=https://github.com/adamdrake><link rel=stylesheet href=https://adamdrake.com/css/style.min.css crossorigin=anonymous media=screen><meta property="og:url" content="https://adamdrake.com/"><meta property="og:title" content="Adam Drake"><meta property="og:site_name" content="Adam Drake"><meta property="og:type" content="website"><meta property="og:description" content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/data, leadership, and building tech teams."><meta name=twitter:title content="Adam Drake"><meta name=twitter:description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/data, leadership, and building tech teams."></head><body><header><section><div class="header flex row"><div class="header__item flex row"><a id=site__name href=https://adamdrake.com/>Adam Drake</a></div><div class="flex row"><nav aria-label="page menu" class="flex row"><ul role=menubar class="flex row"><li role=none><a class=sidebar-nav-itemmenu__item href=/ title>Latest</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/about.html title>About</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/cases.html title>Case Studies</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/contact.html title>Contact</a></li><li role=none><a class="sidebar-nav-item activemenu__item" href=/posts.html title=Posts>Posts</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/press.html title>Press</a></li><li><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button></li></ul></nav></div></div></section></header><main aria-role=main><section><ul id=feed__ul><li class="feed__li h-entry"><div class=feed__content><time class="hidden dt-published">2015-09-07 00:00:00 +0000 UTC</time><div class="flex properties__row"><div rel=author class="flex left p-author h-card"><img class=u-photo src=https://adamdrake.com/static/images/adam_drake_240.jpg alt="Adam Drake" id=author-img><div><p rel=me class=p-name id=author-name>Adam Drake</p><p class=properties>Sep 07, 2015</p></div></div><div class="flex right properties"></div></div><article class="md p-summary e-content"><h2 class=p-name>Are your Functions Total?</h2><p>In recent years, and for a variety of reasons, functional programming has become an increasingly popular topic. Languages like Haskell, Scala, Clojure, and others, have had huge gains in popularity and consequently there have been many large-scale projects written in some of these languages. There has also been increasing pressure to move programming more towards the rigor of mathematics, something which I strongly support.</p><p>One thing which could get more attention in the context of functional programming is the concept of <a href=https://en.wikipedia.org/wiki/Total_functional_programming>Total Functional Programming</a>, which uses the concepts of <strong>total functions</strong> combined with specific types of recursion in order to guarantee that all your programs terminate. Astute readers will note that this means, since the <a href=https://en.wikipedia.org/wiki/Halting_problem>Halting Problem</a> is not decidable over Turing machines, that a Total Functional Programming language is not <a href=https://en.wikipedia.org/wiki/Turing_completeness>Turing Complete</a>. In practical use, this is not an undesirable property and in fact systems written in Turing complete languages are often restricted to be Turing incomplete by, for example, adding termination conditions to programs so that they do not run indefinitely. If you&rsquo;ve ever been working on some kind of numerical program and added something like <code>if loopCounter > limit then return</code> in order to stop a loop which has sufficiently converged, you have done exactly this.</p><p>Another benefit of Total Functional Programing arises due to the <a href=https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence>Curry-Howard Isomorphism</a>, which tells us that programs are representations of mathematical proofs, and therefore if we had a Turing complete language in which these programs (proofs) did not terminate then we would have significant logical inconsistencies. In the total functional programming context, these consistencies are avoided. This can have some nice implications from the theoretical computer science perspective.</p><p>In practical terms though, the benefits of Total Functional Programming, or at least making sure that functions are always total, is that software is more likely to be correct, easier to reason about, and because its construction will be more rigorous we can assume that the results will be of a higher quality. This is especially important in certain classes of systems, but as these tools are becoming more available and known to more developers it makes sense to use them where appropriate. Total functional programming comprises two design aspects, total functions and limited recursion.</p><h1 id=total-functions class=anchor-link><a href=#total-functions>Total functions</a></h1><p>A <strong>total function</strong> is a function which is defined for all elements of its domain. This is in contrast to a <strong>partial function</strong> which is defined only on a subset of its domain. As an example, division as an operation is not total because it is not defined for $0 \in \mathbb{R}$. However, the division function can be made total by specifying a return value for 0.</p><p>The <a href=https://wiki.haskell.org>Haskell wiki</a> has a page specifically devoted to <a href=https://wiki.haskell.org/Avoiding_partial_functions>avoiding partial functions</a> which is worth a read.</p><p>The benefit to keeping your functions total where possible (and it&rsquo;s almost always possible) is that you can eliminate the problem of functions returning values for which there is no proper definition or handling, because the function is defined on all possible values in its domain. In strong and statically typed languages, this allows for the compilers to provide lots of extra support in developing error-free programs since you can have the type checker confirm your functions are not doing to end up in some undefined or error state. The Haskell wiki is helpful when it comes to further examples of non-total functions:</p><p>A good example of this is <code>head</code>. You shouldn&rsquo;t use this function or write functions like it. The problem is in the type, it says <code>[a] -> a</code> which is actually impossible as far as total functions are concerned. Why? Because you might have an empty list! Instead, a more honest type that lets you write a total function would be <code>[a] -> Maybe a</code>. This makes the possibility of not getting a result more explicit and keeps your functions total.</p><p>Another way, besides adding further definitions for elements in your domain for which your function is not defined, would be to exclude those elements from the domain of your functions altogether and to have this exclusion be enforced by the type system. This is possible with <a href=https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types>Refinement Types</a>, which are essentially just types paired with some type of predicate that causes a compile-time error when not satisfied. Note, refinement types are related to <a href=https://en.wikipedia.org/wiki/Liskov_substitution_principle>Behavioral Subtyping</a> (Liskov Substitution Principle, the L in <a href=https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)>SOLID</a>). For the example of the division operator, we could simply exclude 0 as a valid element from the domain of our function. This is straightforward, as you can see in this example using Liquid Haskell:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>{-@ divide :: Int -&gt; {v: Int | v != 0 } -&gt; Int @-}</span>
</span></span></code></pre></div><p>Simply by making all your functions total, you make huge amounts of progress along the path of more stable and correct programs. So do it.</p><p><img class=enclosure src=/static/images/benStiller_doit.jpg alt="Starsky and Hutch meme &lsquo;Do it!&rsquo;"></p><h1 id=restricted-recursion class=anchor-link><a href=#restricted-recursion>Restricted recursion</a></h1><p>This point is a bit more subtle, but necessary in order to achieve guaranteed termination of programs. In order for this termination to occur, we must ensure that there is no infinite recursion. There are a few ways to go about this, the simplest of which is probably <strong>substructural recursion</strong>, which is simply writing functions which only recurse on a subset of the data structure on which it operates (that is, only using <a href=https://en.wikipedia.org/wiki/Primitive_recursive_function>primitive recursive</a> functions). So in the case of a list, the recursion will always occur on a subset of the original list. As an example, if you were summing the even elements of a list then you could do it in the following way (in Haskell):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Haskell data-lang=Haskell><span style=display:flex><span><span style=color:#a6e22e>sumEven</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Int</span>] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sumEven</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sumEven</span> (x<span style=color:#66d9ef>:</span>xs)
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> even x <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> sumEven xs
</span></span><span style=display:flex><span>	<span style=color:#f92672>|</span> otherwise <span style=color:#f92672>=</span> sumEven xs
</span></span></code></pre></div><p>Note also that the way you&rsquo;d implement this in idiomatic Haskell would probably be to simply use :code:<code>sumEven = sum $ filter even</code>, which in the end comes down to a right fold:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Haskell data-lang=Haskell><span style=display:flex><span><span style=color:#a6e22e>sumEven&#39;</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Int</span>] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sumEven&#39;</span> <span style=color:#f92672>=</span> foldr (<span style=color:#f92672>+</span>) <span style=color:#ae81ff>0</span> <span style=color:#f92672>.</span> filter even
</span></span></code></pre></div><p>And also note that the implementation of <code>foldr</code> in the <a href=https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#foldr>Haskell Prelude</a> uses the standard form of substructural recursion with a helper function, traditionally called <code>go</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Haskell data-lang=Haskell><span style=display:flex><span><span style=color:#a6e22e>foldr</span> k z <span style=color:#f92672>=</span> go
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>		go <span style=color:#66d9ef>[]</span>     <span style=color:#f92672>=</span> z
</span></span><span style=display:flex><span>		go (y<span style=color:#66d9ef>:</span>ys) <span style=color:#f92672>=</span> y `k` go ys
</span></span></code></pre></div><p>Note also that the <code>foldr</code> implementation is tail recursive while our original <code>sumEven</code> implementation is not.</p><p><img class=enclosure src=/static/images/xkcd_tailRecursion.png alt="XKCD comic &lsquo;Functional&rsquo;"><br><em>XKCD: <a href=https://www.xkcd.com/1270/>https://www.xkcd.com/1270/</a></em></p><h1 id=conclusion class=anchor-link><a href=#conclusion>Conclusion</a></h1><p>With only these two techniques, we can make use of the benefits of total functional programming. Compile-time checking that functions will never encounter any arguments for which they aren&rsquo;t defined, and confirmation that all computations are terminating, can bring huge amounts of safety and reliability to software. These tools and techniques exist widely and are easy to use in all languages, so there&rsquo;s really no reason not to make use of them wherever you can. It will completely eliminate runtime errors of that sort. Are your functions total? If not, why not?</p><a class=hidden href=https://brid.gy/publish/mastodon></a><a class=hidden href=https://brid.gy/publish/twitter></a><a class=hidden href=https://fed.brid.gy/></a><data class=p-bridgy-omit-link value=false></data></article></div><div id=webmentions></div></li></ul></section></main><hr><footer class="flex col"><section class="footer-bio content"><p><strong>Adam Drake</strong> leads technical business transformations in global and multi-cultural environments. He has a passion for helping companies become more productive by improving internal leadership capabilities, and accelerating product development through technology and data architecture guidance. Adam has served as a White House Presidential Innovation Fellow and is an IEEE Senior Member.</p></section><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button><div class=social-icons><a rel=me href=https://github.com/adamdrake title=GitHub><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></body></html>
<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><meta name=description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/crypto/data, leadership, and building tech teams."><title>An Unreasonably Deep Dive into Project Euler Problem 2 - Adam Drake</title><link rel="shortcut icon" href=/static/favicon.ico><link rel=stylesheet href=https://adamdrake.com/css/main.min.be12b679e5899a8805bab6348a0b4d7dc70275c3a131afa9cf3753df691719da.css integrity="sha256-vhK2eeWJmogFurY0igtNfccCdcOhMa+pzzdT32kXGdo=" media=screen><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://adamdrake.com/static/images/twitter-card.jpg"><meta name=twitter:title content="An Unreasonably Deep Dive into Project Euler Problem 2"><meta name=twitter:description content="First, the problem definition:
 Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &mldr;
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 Classic Fibonacci problem, with a slight twist due to the summation on top."><meta property="og:title" content="An Unreasonably Deep Dive into Project Euler Problem 2"><meta property="og:description" content="First, the problem definition:
 Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &mldr;
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 Classic Fibonacci problem, with a slight twist due to the summation on top."><meta property="og:type" content="article"><meta property="og:url" content="https://adamdrake.com/an-unreasonably-deep-dive-into-project-euler-problem-2.html"><meta property="og:image" content="https://adamdrake.com/static/images/twitter-card.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-01-17T00:00:00+00:00"><meta property="article:modified_time" content="2017-01-17T00:00:00+00:00"></head><body><div class=title-box><div class=title-left><h1 class=name><a href=/>Adam Drake</a></h1></div><div class=title-right><div class=social-icons><a href=https://github.com/adamdrake><img class=icon src=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAC5UlEQVR4nO2a0XXiMBBFKYESKIEOlg5CB3EHmw5wB9DBbgebDnAHTgemA9PB3Q8J1mtkaSSPjTnRPYePHIzem/FoJFtZrTKZTCaTyWQmBFgD78ABOAMNjzT2u4O9dv1s36OwQf8EakewUmo7xuskA9gAR6AdEXif1o65eXZ8XjDlqxm4KxGHZ8f5ALBlXKnHUrOUagAKpr3rQ7TAfgnBP5viOwd/Y94ksKzgb8wzHTAN7xlzPkTLHI0Rf7ffdZJUAleFwK52rK0de+e5tp46+NJn1HH92vGbK1DZz6f93P7uJ6zEsQsMJKycKvgN/tKvAr/dIyhRybU2WUNMMxWAUyDzlbrosBdfAvSrAFPKocZXqYr6/YQS0KL5AAV8BAQBWjXBsB/JKlRoCkr2+Q9NcCqQrS46KwKm/CXsVARlnnxLYZfx0wDZru9TIa5YX6E+ABq7Q8LdH2a8+x1fe4GvUkMolOnZ5r7DW6gXVBoizeQi6d5CN6fREAlRjQ8l2VuwD2iI5AR89wRcJhdJ9xbioiEiWW83o4XifW0EvioNIUkCitFC8b4kG7RKQ0iyETqPDyna11ng66QhJNlxwTKfBVS2wtKHoZoZDjGtH+kplI4f4GsJSYgM/ktTOOYcoMa+wdUEU/ZNhI9CU3zN44NHZRPze8DAH+BNQfvNjhWD/gMaj6vB/YQWcw7g2zCdMUfnwcrA3Okjsi4/xPju7zDmqoKWfwcWW8f3XS4I+oPVCe4+PVwlOqlJcL0cvb+Bxd8rPkbqSBHrJIF7Z1gKzIsbI/J1vk81Rcx9c65S/+89PKaM9zYZOxJKMiH4a0ySRzFwh34pa8QyT/Adg675flQcP4ZCSzfWpCsJDWbJ+9H5vCeMvezgO0Z3CE5qEsYNMd+cD4FpjN73Bglj+qgWE3wXTNd3VkPCWEN3fdp1fiyYJfDUT0TCOP3AT7zS/wyvVvcmWZGwN7cB3x64XivwTCaTyWQymVfgL42yxWFGEKJcAAAAAElFTkSuQmCC width=64 height=64></a>
<a href=https://twitter.com/aadrake><img class=icon src=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAACQ0lEQVR4nO2a0XWjMBBFXQIluIR0EDpIOjAdLB1kO0g6sDvIdgAd2B3gDkwHNx8jEkIMNmTGkvfMPUc//hjmPTTSIHm1chzHcRzHcRzHSQggAx6BlzA2wEPsvMwBcqBinCYYkl2I8WyRXKEe9Ct2BmwnhJ8z4mEQ46ln3lo7wTwELlQDrz7F72eI7zgBr8D74Pc37RxXwK73gEI59naB+DEOTJTHb5IcvqFCKW7+U8PvxIex0cqxS/QcW4W4jZL4rhyqvhka2rtEx9izcHsC1krih7RLc5pK9jDxwBMXtqaRmKWB+KO6+JDsvyse3gCbGTH/Kou3WQBDssWMRBrgz6VkDAywER+SzZDamkuFmPFjWqJsgJn4XsIaNVsh+/4L0y3vbMwNCCZcsxZEwVr4K7JtZXzvClOhtTagY49M3VMcnaPU1gZM9QEpsLM24C22wgsU1gZYta1a2J8Wke4sOJqLDwZkpLkW6B+A3JkJtz0sRUxIpRwONxU/MGKNNEXHiAYUMYQ/I81QN2I1Rcebiw8GrFn2ZaiN/tn/DBO0v+XnUkcT3zOhjiS+RfviY6EBGXE+j4vY2r+BHJTcak3YxdZ7FmQ2lMiMsDIj3p4/B+S2p9EWj+WhpwbILBheVGpQJy0e6Qu2BsIh4Zp/RM4Jl1xrX0NLzEanJzRH+v0K/boeI70pj3R+1ltdDeSxtU6CXJFpdoAtMsPu6w9QyMJXsuxz+ICcJ8SvcS2QLTAPo0RKphtl+P2+3rLjOI7jOI7jOP8tH5ahgbeYuZE9AAAAAElFTkSuQmCC width=64 height=64></a>
<a href=https://linkedin.com/in/aadrake><img class=icon src=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAAzElEQVRIie2WWxGDMBBFVwISkIAEnBQJOCoOKqE4AAeNg+Lg9AOY2VmSTls29If7eTPJmbubl8gioAEG/DQAF9ECOkeA1VUnya1GgPEA0CARs2dO2QLBi2RBAShU78pcoF6MgCkH6AlUClJ7QGKgFXYD7l6QFOhbBeYN9Hb3bkCRHqX8CaiNV6aAe0CV9Ra/IHIsfgapRYuIv7lt9iTSi7VmbHP+9oB0eR6peR6gj+adoBP0X9ART/l43OdkiZnzu9XZmjb4lnFkTSIiLyov4WUSpGLDAAAAAElFTkSuQmCC width=64 height=64></a>
<a href=/index.xml><img class=icon src=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAABOElEQVRIib2WXXWEMBBGIyESkICDroPWQSNhHRQnrANwsOsAHFAJdXD7ALSz0wmZLrTfObwwkDs/X3ISwiIgAQPHaQBegxRwORCg1cpK/lopAKN6eQEaoAduwPsBoCFoSDAEVMDZSMotF0hBT8yV7gIBtMAb8Aw8ATEDTMDHHpClDm3VGVbjbKcXtGrSQCB6YL8FreoQLfXALJC099bPg4LVbMys6DpmazdOWHbzu+29AK0KO/Wdaf2SvaNaJGKfi0ntMxfIApcGP6mEflTudd0E1KqNWrKq86OgFSYr0wbplQMfBoEwC3ZVMpG7U98C3ZZFKmwHZRcDTjn3WaCqkPWLiPfemAWKBVCzMadszAJd+W7d1YjLOek9lY2ZnneoXR5vbPy/y0mmBUfqq50rLLHj8mFoRJwWnzknvtUm1yWnAAAAAElFTkSuQmCC width=64 height=64></a></div><div class=subscribe><form action=https://api.digitalmaneuver.com/subscribe method=get><input class=subscribe-field style=width:200px name=email placeholder=" Subscribe to newsletter? " type=text>
<input class=subscribe-btn value=Yes! type=submit></form></div></div></div><div class="nav-box row"><div class=nav-left-menu><ul><li><a href=/>Latest</a> |</li><li><a href=/about.html>About</a> |</li><li><a href=/cases.html>Case Studies</a> |</li><li><a href=/contact.html>Contact</a> |</li><li><a href=/press.html>Press</a></li></ul></div></div><section class=section><div class=container><a href=https://applybyapi.com><button class=btn>Struggling to hire developers? Check out ApplyByAPI!</button></a><h1 class=page-title>An Unreasonably Deep Dive into Project Euler Problem 2</h1><h2 class=content-date>January 17, 2017</h2><div class=share-links>Share this:
<a class=twitter-share-button href="https://twitter.com/intent/tweet?text=Read%20An%20Unreasonably%20Deep%20Dive%20into%20Project%20Euler%20Problem%202%20https%3a%2f%2fadamdrake.com%2fan-unreasonably-deep-dive-into-project-euler-problem-2.html" onclick="return window.open(this.href,'twitter-share','width=550,height=235'),!1">twitter</a> //
<a class=icon-facebook href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fadamdrake.com%2fan-unreasonably-deep-dive-into-project-euler-problem-2.html" onclick="return window.open(this.href,'facebook-share','width=580,height=296'),!1">facebook</a> //
<a class=icon-linkedin href="https://www.linkedin.com/shareArticle?mini=true&url=https://adamdrake.com&title=An%20Unreasonably%20Deep%20Dive%20into%20Project%20Euler%20Problem%202&source=Adam%20Drake" onclick="return window.open(this.href,'linkedin-share','width=980,height=980'),!1">linkedin</a> //
<a class=icon-google-plus href="https://plus.google.com/share?url=https%3a%2f%2fadamdrake.com%2fan-unreasonably-deep-dive-into-project-euler-problem-2.html" onclick="return window.open(this.href,'google-plus-share','width=490,height=530'),!1">google+</a></div><div class=content><p>First, the problem definition:</p><blockquote><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &mldr;</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p></blockquote><p>Classic Fibonacci problem, with a slight twist due to the summation on top. Spoiler alert: a simple loop is fastest. Keep reading to see why.</p><h1 id=first-attempt-recursion class=anchor-link><a href=#first-attempt-recursion>First Attempt: Recursion</a></h1><p>The Fibonacci sequence is defined as f(n) = f(n-1) + f(n-2) where the first two elements are defined in this problem as f(1) = 1 and f(2) = 2.</p><p>This means</p><p>f(3) = f(2) + f(1) = 2 + 1 = 3,</p><p>f(4) = f(3) + f(2) = 3 + 2 = 5,</p><p>and so on.</p><p>This recursive definition translates easily into most programming languages although, as we&rsquo;ll see, the performance isn&rsquo;t the best.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>fibsRecursion</span>(limit <span style=color:#078;font-weight:700>int</span>) <span style=color:#078;font-weight:700>int</span> {
	<span style=color:#069;font-weight:700>if</span> limit <span style=color:#555>&lt;=</span> <span style=color:#f60>2</span> {
		<span style=color:#069;font-weight:700>return</span> limit
	}
	<span style=color:#069;font-weight:700>return</span> <span style=color:#c0f>fibsRecursion</span>(limit<span style=color:#555>-</span><span style=color:#f60>2</span>) <span style=color:#555>+</span> <span style=color:#c0f>fibsRecursion</span>(limit<span style=color:#555>-</span><span style=color:#f60>1</span>)
}
</code></pre></div><p>This function takes an input <code>limit</code> and will generate the nth Fibonacci number. The function alone doesn&rsquo;t solve our problem, because we still need to calculate the whole sequence of numbers, check if each is even, and add the even ones to the sum. We can wrap that functionality in a small <code>for</code> loop.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>sumEvenFibsRecursion</span>(limit <span style=color:#078;font-weight:700>int</span>) <span style=color:#078;font-weight:700>int</span> {
	sum <span style=color:#555>:=</span> <span style=color:#f60>0</span>
	next <span style=color:#555>:=</span> <span style=color:#f60>0</span>
	<span style=color:#069;font-weight:700>for</span> i <span style=color:#555>:=</span> <span style=color:#f60>1</span>; next &lt; limit; i<span style=color:#555>++</span> {
		next = <span style=color:#c0f>fibsRecursion</span>(i)
		<span style=color:#069;font-weight:700>if</span> <span style=color:#c0f>isEven</span>(next) {
			sum <span style=color:#555>+=</span> next
		}
	}
	<span style=color:#069;font-weight:700>return</span> sum
}
</code></pre></div><p>Where <code>isEven</code> is a small helper function to cut down on typing.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>isEven</span>(x <span style=color:#078;font-weight:700>int</span>) <span style=color:#078;font-weight:700>bool</span> {
	<span style=color:#069;font-weight:700>if</span> math.<span style=color:#c0f>Mod</span>(<span style=color:#366>float64</span>(x), <span style=color:#f60>2</span>) <span style=color:#555>==</span> <span style=color:#f60>0</span> {
		<span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>true</span>
	}
	<span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>false</span>
}
</code></pre></div><p>Ok, now we can calculate Fibonacci numbers, iterate up to a limit, check if they are even, and sum them. There are also tests and a benchmark, for completeness.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>package</span> main

<span style=color:#069;font-weight:700>import</span> <span style=color:#c30>&#34;testing&#34;</span>

<span style=color:#069;font-weight:700>const</span> LIMIT <span style=color:#078;font-weight:700>int</span> = <span style=color:#f60>3999999</span>
<span style=color:#069;font-weight:700>const</span> SUM_LIMIT <span style=color:#078;font-weight:700>int</span> = <span style=color:#f60>4613732</span>

<span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>TestIsEven</span>(t <span style=color:#555>*</span>testing.T) {
	<span style=color:#069;font-weight:700>if</span> (<span style=color:#c0f>isEven</span>(<span style=color:#f60>4</span>) <span style=color:#555>!=</span> <span style=color:#069;font-weight:700>true</span>) <span style=color:#555>||</span> (<span style=color:#c0f>isEven</span>(<span style=color:#f60>3</span>) <span style=color:#555>!=</span> <span style=color:#069;font-weight:700>false</span>) {
		t.<span style=color:#c0f>Fatal</span>(<span style=color:#c30>&#34;isEven returned incorrect value&#34;</span>)
	}
}

<span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>TestFibsRecursion</span>(t <span style=color:#555>*</span>testing.T) {
	firstTen <span style=color:#555>:=</span> []<span style=color:#078;font-weight:700>int</span>{<span style=color:#f60>1</span>, <span style=color:#f60>2</span>, <span style=color:#f60>3</span>, <span style=color:#f60>5</span>, <span style=color:#f60>8</span>, <span style=color:#f60>13</span>, <span style=color:#f60>21</span>, <span style=color:#f60>34</span>, <span style=color:#f60>55</span>, <span style=color:#f60>89</span>}
	<span style=color:#069;font-weight:700>for</span> i, v <span style=color:#555>:=</span> <span style=color:#069;font-weight:700>range</span> firstTen {
		fib <span style=color:#555>:=</span> <span style=color:#c0f>fibsRecursion</span>(i <span style=color:#555>+</span> <span style=color:#f60>1</span>)
		<span style=color:#069;font-weight:700>if</span> fib <span style=color:#555>!=</span> v {
			t.<span style=color:#c0f>Fatal</span>(<span style=color:#c30>&#34;recursion gave&#34;</span>, fib, <span style=color:#c30>&#34;want&#34;</span>, v)
		}
	}
}

<span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>TestSumEvenFibsRecursion</span>(t <span style=color:#555>*</span>testing.T) {
	result <span style=color:#555>:=</span> <span style=color:#c0f>sumEvenFibsRecursion</span>(LIMIT)
	<span style=color:#069;font-weight:700>if</span> result <span style=color:#555>!=</span> SUM_LIMIT {
		t.<span style=color:#c0f>Fatal</span>(<span style=color:#c30>&#34;wanted&#34;</span>, SUM_LIMIT, <span style=color:#c30>&#34;got&#34;</span>, result)
	}
}

<span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>BenchmarkSumEvenFibsRecursion</span>(b <span style=color:#555>*</span>testing.B) {
	<span style=color:#069;font-weight:700>for</span> i <span style=color:#555>:=</span> <span style=color:#f60>0</span>; i &lt; b.N; i<span style=color:#555>++</span> {
		<span style=color:#c0f>sumEvenFibsRecursion</span>(LIMIT)
	}
}
</code></pre></div><p>We can run the tests and see that everything passes.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#555>===</span> RUN   TestIsEven
--- PASS: TestIsEven <span style=color:#555>(</span>0.00s<span style=color:#555>)</span>
<span style=color:#555>===</span> RUN   TestFibsRecursion
--- PASS: TestFibsRecursion <span style=color:#555>(</span>0.00s<span style=color:#555>)</span>
<span style=color:#555>===</span> RUN   TestSumEvenFibsRecursion
--- PASS: TestSumEvenFibsRecursion <span style=color:#555>(</span>0.05s<span style=color:#555>)</span>
</code></pre></div><p>Now on to the benchmark so we can look at the performance characteristics of this approach.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>BenchmarkSumEvenFibsRecursion-4               <span style=color:#f60>30</span>          <span style=color:#f60>46091679</span> ns/op
</code></pre></div><p>That is extremely slow, as expected. The recursive approach is doing a ton of unnecessary work. Additionally, <a href=https://en.wikipedia.org/wiki/Tail_call>tail-call optimization</a> is not always supported in Go, at least there was no <a href=https://groups.google.com/forum/#!msg/golang-nuts/0oIZPHhrDzY/2nCpUZDKZAAJ>plan to implement TCO more broadly</a>, which also can result in memory usage or performance characteristics that are difficult to analyze or plan for.</p><p>From a time and space complexity perspective, we can think of the space complexity first. There will be a function call, recursively, for each Fibonacci number calculated. So if we want the first 5 numbers, we&rsquo;ll have 5 function calls on the stack. The depth of the stack is <code>O(n)</code> and memory requirement will be <code>N * frameSize</code>, where frameSize is the size of the frame inserted into the stack with each function call.</p><p>On the time complexity side, the short version is the bound on time complexity is <code>O(2^n)</code>.</p><p>The slightly longer version is that the tight bound is <code>O(Phi^n)</code> where <code>Phi</code> is the so-called <em>golden ratio</em> 1.618&mldr; and <code>n</code> is the nth Fibonacci number. In other words, it&rsquo;s still exponential but with a slightly smaller base. To see why, consider that the recurrence relation use to generate the sequence is proportional to the time complexity required to calculated it. At that point you can use the closed-form approximation for the Fibonacci sequence numbers themselves. Since the numbers in the sequence grow as <code>O(Phi)</code> then the time complexity grows that way too.</p><h1 id=second-attempt-iteration class=anchor-link><a href=#second-attempt-iteration>Second Attempt: Iteration</a></h1><p>In the recursive case, we were recalculating the Fibonacci numbers all the time, which leads to a lot of wasted computation. Consider that for computing <code>F(4)</code> (the fourth Fibonacci number) we would compute <code>F(3) + F(2) + F(1)</code>, but we already have <code>F(2) and F(1)</code> when we computed <code>F(3)</code>, so why computer them again? Instead of starting from a limit and calling functions all the way down as our recursive function did, we can simply build up the list of Fibonacci numbers from the bottom. This allows us to use numbers already calculated to calculate the next number in the sequence.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>sumEvenFibsSlice</span>(limit <span style=color:#078;font-weight:700>int</span>) <span style=color:#078;font-weight:700>int</span> {
	fibs <span style=color:#555>:=</span> []<span style=color:#078;font-weight:700>int</span>{<span style=color:#f60>1</span>, <span style=color:#f60>2</span>}
	newElement <span style=color:#555>:=</span> <span style=color:#f60>0</span>
	<span style=color:#069;font-weight:700>for</span> i <span style=color:#555>:=</span> <span style=color:#f60>2</span>; newElement &lt; limit; i<span style=color:#555>++</span> {
		newElement = fibs[i<span style=color:#555>-</span><span style=color:#f60>1</span>] <span style=color:#555>+</span> fibs[i<span style=color:#555>-</span><span style=color:#f60>2</span>]
		fibs = <span style=color:#366>append</span>(fibs, newElement)
	}
	<span style=color:#069;font-weight:700>return</span> <span style=color:#c0f>sumEvens</span>(fibs)
}
</code></pre></div><p>In this example, we start with a slice that has the first two numbers as given in the problem, and then appends the remaining numbers onto the slice until the new element in the sequence is greater than or equal to the limit, at which point we return the sum of the even numbers in the slice.</p><p>We can write the test and benchmark code as before.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>TestSumEvenFibsSlice</span>(t <span style=color:#555>*</span>testing.T) {
	<span style=color:#069;font-weight:700>if</span> <span style=color:#c0f>sumEvenFibsSlice</span>(LIMIT) <span style=color:#555>!=</span> SUM_LIMIT {
		t.<span style=color:#c0f>Fatal</span>(<span style=color:#c30>&#34;&#34;</span>)
	}
}

<span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>BenchmarkSumEvenFibsSlice</span>(b <span style=color:#555>*</span>testing.B) {
	<span style=color:#069;font-weight:700>for</span> i <span style=color:#555>:=</span> <span style=color:#f60>0</span>; i &lt; b.N; i<span style=color:#555>++</span> {
		<span style=color:#c0f>sumEvenFibsSlice</span>(LIMIT)
	}
}
</code></pre></div><p>Which gives us passing tests and a new benchmark number.</p><pre><code>BenchmarkSumEvenFibsSlice-4               200000              6210 ns/op
</code></pre><p>This is a faster approach compared to the recursive solution, by a lot. In fact the recursive solution takes about 7400 times longer, so we&rsquo;re on the right track.</p><p>Now that we have an iterative solution, many newcomers to Go will think that it makes sense to spin off a thread/goroutine to do the calculations and pass the results back over a channel for our function to use.</p><h1 id=winner-a-simple-loop class=anchor-link><a href=#winner-a-simple-loop>Winner: a simple loop</a></h1><p>Slices perform acceptably, but they&rsquo;re still relatively slow. We can do better by using a simple loop and accumulating our sum along the way. The code starts index <code>i</code> and <code>j</code> at 1, and adds and swaps them until the limit is reached. The benefit of this approach is that we are only using a few integer values, and we are only iterating until we reach the limit, so this approach is linear for our values.</p><p><strong>NOTE</strong> that there is a caveat here as we are dealing with values which fit into a normal <code>int</code> type in Go. If the integers become too big and we need to use arbitrarily-large integers, we will have different performance characteristics. For our purposes though, the simple looping approach has <code>O(n)</code> time complexity.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>sumEvenFibsLoop</span>(limit <span style=color:#078;font-weight:700>int</span>) <span style=color:#078;font-weight:700>int</span> {
	sum <span style=color:#555>:=</span> <span style=color:#f60>0</span>
	<span style=color:#069;font-weight:700>for</span> i, j <span style=color:#555>:=</span> <span style=color:#f60>1</span>, <span style=color:#f60>1</span>; j &lt; limit; i, j = i<span style=color:#555>+</span>j, i {
		<span style=color:#069;font-weight:700>if</span> <span style=color:#c0f>isEven</span>(i) {
			sum <span style=color:#555>+=</span> i
		}
	}
	<span style=color:#069;font-weight:700>return</span> sum
}
</code></pre></div><p>Test and benchmark:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>TestSumEvenFibsLoop</span>(t <span style=color:#555>*</span>testing.T) {
	<span style=color:#069;font-weight:700>if</span> <span style=color:#c0f>sumEvenFibsLoop</span>(LIMIT) <span style=color:#555>!=</span> SUM_LIMIT {
		t.<span style=color:#c0f>Fatal</span>(<span style=color:#c30>&#34;sumevenfibloop&#34;</span>)
	}

}

<span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>BenchmarkSumEvenFibsLoop</span>(b <span style=color:#555>*</span>testing.B) {
	<span style=color:#069;font-weight:700>for</span> i <span style=color:#555>:=</span> <span style=color:#f60>0</span>; i &lt; b.N; i<span style=color:#555>++</span> {
		<span style=color:#c0f>sumEvenFibsLoop</span>(LIMIT)
	}
}
</code></pre></div><pre><code>BenchmarkSumEvenFibsLoop-4                300000              5535 ns/op
</code></pre><p>The performance of this approach is the best so far, but just barely. It outperforms the slice approach, but not by much.</p><h1 id=digression-channels class=anchor-link><a href=#digression-channels>Digression: Channels</a></h1><p>A common thing newcomers do when they pick up Go is they reach for channels and goroutines. Although these are awesome tools and it&rsquo;s great they are so easy to use in the language, they aren&rsquo;t always good for performance. The short reason is that channels are essentially a mutable data structure, and therefore require locks. Locks are an enemy of performance, so in many tasks you will slow down your computations if you use channels and goroutines.</p><p>For example, we can use the standard approach of creating a function which returns a channel of values. We&rsquo;ll drop our iterative solution from before into a function which is spun off as its own goroutine.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>fibsChannel</span>(limit <span style=color:#078;font-weight:700>int</span>) <span style=color:#069;font-weight:700>chan</span> <span style=color:#078;font-weight:700>int</span> {
	output <span style=color:#555>:=</span> <span style=color:#366>make</span>(<span style=color:#069;font-weight:700>chan</span> <span style=color:#078;font-weight:700>int</span>)
	<span style=color:#069;font-weight:700>go</span> <span style=color:#069;font-weight:700>func</span>() {
		<span style=color:#069;font-weight:700>defer</span> <span style=color:#366>close</span>(output)
		<span style=color:#069;font-weight:700>for</span> i, j <span style=color:#555>:=</span> <span style=color:#f60>1</span>, <span style=color:#f60>1</span>; j &lt; limit; i, j = i<span style=color:#555>+</span>j, i {
			output <span style=color:#555>&lt;-</span> i
		}
	}()
	<span style=color:#069;font-weight:700>return</span> output
}
</code></pre></div><p>We can use this for our specific problem in the following way.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>sumEvenFibsChannel</span>(limit <span style=color:#078;font-weight:700>int</span>) <span style=color:#078;font-weight:700>int</span> {
	sum <span style=color:#555>:=</span> <span style=color:#f60>0</span>
	fibs <span style=color:#555>:=</span> <span style=color:#c0f>fibsChannel</span>(limit)
	<span style=color:#069;font-weight:700>for</span> f <span style=color:#555>:=</span> <span style=color:#069;font-weight:700>range</span> fibs {
		<span style=color:#069;font-weight:700>if</span> <span style=color:#c0f>isEven</span>(f) {
			sum <span style=color:#555>+=</span> f
		}
	}
	<span style=color:#069;font-weight:700>return</span> sum
}
</code></pre></div><p>along with the accompanying tests and benchmarks.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>TestFibsChannel</span>(t <span style=color:#555>*</span>testing.T) {
	firstTen <span style=color:#555>:=</span> []<span style=color:#078;font-weight:700>int</span>{<span style=color:#f60>1</span>, <span style=color:#f60>2</span>, <span style=color:#f60>3</span>, <span style=color:#f60>5</span>, <span style=color:#f60>8</span>, <span style=color:#f60>13</span>, <span style=color:#f60>21</span>, <span style=color:#f60>34</span>, <span style=color:#f60>55</span>, <span style=color:#f60>89</span>}
	fibs <span style=color:#555>:=</span> <span style=color:#c0f>fibsChannel</span>(<span style=color:#f60>90</span>)
	<span style=color:#069;font-weight:700>for</span> _, v <span style=color:#555>:=</span> <span style=color:#069;font-weight:700>range</span> firstTen {
		chanVal <span style=color:#555>:=</span> <span style=color:#555>&lt;-</span>fibs
		<span style=color:#069;font-weight:700>if</span> v <span style=color:#555>!=</span> chanVal {
			t.<span style=color:#c0f>Fatal</span>(<span style=color:#c30>&#34;fibChannel incorrect.  Expected&#34;</span>, v, <span style=color:#c30>&#34;but received&#34;</span>, chanVal)
		}
	}
}

<span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>TestSumEvenFibsChannel</span>(t <span style=color:#555>*</span>testing.T) {
	<span style=color:#069;font-weight:700>if</span> <span style=color:#c0f>sumEvenFibsChannel</span>(LIMIT) <span style=color:#555>!=</span> SUM_LIMIT {
		t.<span style=color:#c0f>Fatal</span>(<span style=color:#c30>&#34;&#34;</span>)
	}
}

<span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>BenchmarkSumEvenFibsChannel</span>(b <span style=color:#555>*</span>testing.B) {
	<span style=color:#069;font-weight:700>for</span> i <span style=color:#555>:=</span> <span style=color:#f60>0</span>; i &lt; b.N; i<span style=color:#555>++</span> {
		<span style=color:#c0f>sumEvenFibsChannel</span>(LIMIT)
	}
}
</code></pre></div><p>All the tests pass, and we can get a look at the performance of the channels approach.</p><pre><code>BenchmarkSumEvenFibsChannel-4             100000             18677 ns/op
</code></pre><p>At 18,677 ns/op the channels approach takes around 3 times as long as the slices approach, and about 3.4 times as long as the simple loop, so although channels and goroutines are a wonderful part of the language, they are not a good fit for all problems.</p><h1 id=digression-solution-by-approximation class=anchor-link><a href=#digression-solution-by-approximation>Digression: Solution by approximation</a></h1><p>It was briefly mentioned earlier that the runtime complexity of the recursive solution is <code>O(Phi^n)</code> where <code>Phi</code> is the <a href=https://en.wikipedia.org/wiki/Golden_ratio#Relationship_to_Fibonacci_sequence>Golden Ratio</a>. With some further analysis you can show that the Nth Fibonacci number can be approximated by <code>1/sqrt(5) * Phi^(n+1)</code>. We can use this method to generate our Fibonacci numbers as well.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>fibApprox</span>(n <span style=color:#078;font-weight:700>int</span>) <span style=color:#078;font-weight:700>int</span> {
	fib <span style=color:#555>:=</span> (<span style=color:#f60>1</span> <span style=color:#555>/</span> math.<span style=color:#c0f>Sqrt</span>(<span style=color:#f60>5</span>)) <span style=color:#555>*</span> math.<span style=color:#c0f>Pow</span>(math.Phi, <span style=color:#366>float64</span>(n<span style=color:#555>+</span><span style=color:#f60>1</span>))
    <span style=color:#069;font-weight:700>return</span> <span style=color:#366>int</span>(fib <span style=color:#555>+</span> <span style=color:#f60>0.5</span>) <span style=color:#09f;font-style:italic>//  BUG: This only works for postive numbers
</span><span style=color:#09f;font-style:italic></span>}
</code></pre></div><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>TestFibApprox</span>(t <span style=color:#555>*</span>testing.T) {
	firstTen <span style=color:#555>:=</span> []<span style=color:#078;font-weight:700>int</span>{<span style=color:#f60>1</span>, <span style=color:#f60>2</span>, <span style=color:#f60>3</span>, <span style=color:#f60>5</span>, <span style=color:#f60>8</span>, <span style=color:#f60>13</span>, <span style=color:#f60>21</span>, <span style=color:#f60>34</span>, <span style=color:#f60>55</span>, <span style=color:#f60>89</span>}
	<span style=color:#069;font-weight:700>for</span> i, v <span style=color:#555>:=</span> <span style=color:#069;font-weight:700>range</span> firstTen {
		fib <span style=color:#555>:=</span> <span style=color:#c0f>fibApprox</span>(i <span style=color:#555>+</span> <span style=color:#f60>1</span>)
		<span style=color:#069;font-weight:700>if</span> fib <span style=color:#555>!=</span> v {
			t.<span style=color:#c0f>Fatal</span>(<span style=color:#c30>&#34;got&#34;</span>, fib, <span style=color:#c30>&#34;want&#34;</span>, v)
		}
	}
}

<span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>TestSumEvenFibsApprox</span>(t <span style=color:#555>*</span>testing.T) {
	<span style=color:#069;font-weight:700>if</span> <span style=color:#c0f>sumEvenFibsApprox</span>(LIMIT) <span style=color:#555>!=</span> SUM_LIMIT {
		t.<span style=color:#c0f>Fatal</span>(<span style=color:#c30>&#34;&#34;</span>)
	}
}

<span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>BenchmarkSumEvenFibsApprox</span>(b <span style=color:#555>*</span>testing.B) {
	<span style=color:#069;font-weight:700>for</span> i <span style=color:#555>:=</span> <span style=color:#f60>0</span>; i &lt; b.N; i<span style=color:#555>++</span> {
		<span style=color:#c0f>sumEvenFibsApprox</span>(LIMIT)
	}
}
</code></pre></div><p>However, although we have a closed-form solution it is not yet faster than our simple loop implementation.</p><pre><code>BenchmarkSumEvenFibsApprox-4              200000              7769 ns/op
</code></pre><p>Part of the reason for this is because for the numbers we&rsquo;re dealing with, which fit into 64 bit integers, the simple loop has an apparently linear time complexity. However, once we get into arbitrarily large numbers and need something from <code>math/big</code> then we won&rsquo;t have the same performance characteristics and the closed-form solution may be faster, even though it does contain exponentiation. Recall that <a href=https://en.wikipedia.org/wiki/Exponentiation_by_squaring>exponentiation by squaring</a> has a computational complexity of about <code>O(log n)</code>.</p><h1 id=bonus-round-bitwise-and-for-evenodd-checking class=anchor-link><a href=#bonus-round-bitwise-and-for-evenodd-checking>Bonus Round: Bitwise and for even/odd checking</a></h1><p>Although the fastest approach we tested was the simple loop, we were still using the <code>isEven()</code> function, which used modular arithmetic to tell us if the integer was even or not. I also wanted to check to see if there would be a significant speedup from switching to <a href=https://en.wikipedia.org/wiki/Bitwise_operation#AND>bitwise operations</a> to check the <a href=https://en.wikipedia.org/wiki/Parity_(mathematics)>parity</a> of the numbers.</p><p>The short version is that replacing the <code>math.Mod()</code> call with a bitwise <code>and</code>, we can determine the parity of the number in a much more computationally-efficient way.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>isEven</span>(x <span style=color:#078;font-weight:700>int</span>) <span style=color:#078;font-weight:700>bool</span> {
	<span style=color:#069;font-weight:700>if</span> x<span style=color:#555>&amp;</span><span style=color:#f60>1</span> <span style=color:#555>==</span> <span style=color:#f60>0</span> {
		<span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>true</span>
	}
	<span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>false</span>
}
</code></pre></div><p>I had benchmarks for <code>isEven()</code> before and after.</p><p>Before:</p><pre><code>BenchmarkIsEvenEven-4                   30000000                43.5 ns/op
BenchmarkIsEvenOdd-4                    30000000                44.8 ns/op
</code></pre><p>After:</p><pre><code>BenchmarkIsEvenEven-4                   2000000000               0.34 ns/op
BenchmarkIsEvenOdd-4                    2000000000               0.34 ns/op
</code></pre><p>This is a performance improvement of <strong>130 times</strong>.</p><p>When we use this bitwise version for the parity checking in the other algorithms, we see the expected speedups.</p><pre><code>BenchmarkSumEvenFibsSlice-4              3000000               455 ns/op
BenchmarkSumEvenFibsRecursion-4               30          46208502 ns/op
BenchmarkSumEvenFibsLoop-4              30000000                49.7 ns/op
BenchmarkSumEvenFibsChannel-4             100000             11670 ns/op
BenchmarkSumEvenFibsApprox-4             1000000              1766 ns/op
</code></pre><p>If we wanted to further speed up the simple loop, we could remove the overhead of the function call to <code>isEven()</code> and inline the bitwise and.</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>sumEvenFibsLoop</span>(limit <span style=color:#078;font-weight:700>int</span>) <span style=color:#078;font-weight:700>int</span> {
	sum <span style=color:#555>:=</span> <span style=color:#f60>0</span>
	<span style=color:#069;font-weight:700>for</span> i, j <span style=color:#555>:=</span> <span style=color:#f60>1</span>, <span style=color:#f60>1</span>; j &lt; limit; i, j = i<span style=color:#555>+</span>j, i {
		<span style=color:#069;font-weight:700>if</span> i<span style=color:#555>&amp;</span><span style=color:#f60>1</span> <span style=color:#555>==</span> <span style=color:#f60>0</span> {
			sum <span style=color:#555>+=</span> i
		}
	}
	<span style=color:#069;font-weight:700>return</span> sum
}
</code></pre></div><p>Which cuts off a bit more time, about 11%.</p><pre><code>BenchmarkSumEvenFibsLoop-4      30000000                44.0 ns/op
</code></pre><h1 id=conclusion class=anchor-link><a href=#conclusion>Conclusion</a></h1><p>Project Euler problems, in addition to fun programming exercises, can be great ways to refresh mathematics and computer science skills you may have forgotten or may not have used in a while. For this problem alone we got into time and memory complexity, recurence relations, recursion, channels and goroutines, bitwise operations, and testing and benchmarking in Go.</p><p>We could have gone further down the rabbit hole, especially on the mathematics side of things, but then it would be <a href=https://en.wikipedia.org/wiki/Turtles_all_the_way_down>turtles all the way down</a> and we wouldn&rsquo;t be able to move on to other problems.</p></div></div></section><div class="nav-box row"><div class=nav-left-menu><ul><li><a href=/>Latest</a> |</li><li><a href=/about.html>About</a> |</li><li><a href=/cases.html>Case Studies</a> |</li><li><a href=/contact.html>Contact</a> |</li><li><a href=/press.html>Press</a></li></ul></div></div><div class="footer-box row"><div class="footer-left col-md-6 col-xs-12"><div class="footer-bio content"><p><strong>Adam Drake</strong> leads technical business transformations in global and multi-cultural environments. He has a passion for helping companies become more productive by improving internal leadership capabilities, and accelerating product development through technology and data architecture guidance. Adam has served as a White House Presidential Innovation Fellow and is an IEEE Senior Member.</p></div></div><div class=footer-right><div class=social-icons><a href=https://github.com/adamdrake><img class=icon src=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAC5UlEQVR4nO2a0XXiMBBFKYESKIEOlg5CB3EHmw5wB9DBbgebDnAHTgemA9PB3Q8J1mtkaSSPjTnRPYePHIzem/FoJFtZrTKZTCaTyWQmBFgD78ABOAMNjzT2u4O9dv1s36OwQf8EakewUmo7xuskA9gAR6AdEXif1o65eXZ8XjDlqxm4KxGHZ8f5ALBlXKnHUrOUagAKpr3rQ7TAfgnBP5viOwd/Y94ksKzgb8wzHTAN7xlzPkTLHI0Rf7ffdZJUAleFwK52rK0de+e5tp46+NJn1HH92vGbK1DZz6f93P7uJ6zEsQsMJKycKvgN/tKvAr/dIyhRybU2WUNMMxWAUyDzlbrosBdfAvSrAFPKocZXqYr6/YQS0KL5AAV8BAQBWjXBsB/JKlRoCkr2+Q9NcCqQrS46KwKm/CXsVARlnnxLYZfx0wDZru9TIa5YX6E+ABq7Q8LdH2a8+x1fe4GvUkMolOnZ5r7DW6gXVBoizeQi6d5CN6fREAlRjQ8l2VuwD2iI5AR89wRcJhdJ9xbioiEiWW83o4XifW0EvioNIUkCitFC8b4kG7RKQ0iyETqPDyna11ng66QhJNlxwTKfBVS2wtKHoZoZDjGtH+kplI4f4GsJSYgM/ktTOOYcoMa+wdUEU/ZNhI9CU3zN44NHZRPze8DAH+BNQfvNjhWD/gMaj6vB/YQWcw7g2zCdMUfnwcrA3Okjsi4/xPju7zDmqoKWfwcWW8f3XS4I+oPVCe4+PVwlOqlJcL0cvb+Bxd8rPkbqSBHrJIF7Z1gKzIsbI/J1vk81Rcx9c65S/+89PKaM9zYZOxJKMiH4a0ySRzFwh34pa8QyT/Adg675flQcP4ZCSzfWpCsJDWbJ+9H5vCeMvezgO0Z3CE5qEsYNMd+cD4FpjN73Bglj+qgWE3wXTNd3VkPCWEN3fdp1fiyYJfDUT0TCOP3AT7zS/wyvVvcmWZGwN7cB3x64XivwTCaTyWQymVfgL42yxWFGEKJcAAAAAElFTkSuQmCC width=64 height=64></a>
<a href=https://twitter.com/aadrake><img class=icon src=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAACQ0lEQVR4nO2a0XWjMBBFXQIluIR0EDpIOjAdLB1kO0g6sDvIdgAd2B3gDkwHNx8jEkIMNmTGkvfMPUc//hjmPTTSIHm1chzHcRzHcRzHSQggAx6BlzA2wEPsvMwBcqBinCYYkl2I8WyRXKEe9Ct2BmwnhJ8z4mEQ46ln3lo7wTwELlQDrz7F72eI7zgBr8D74Pc37RxXwK73gEI59naB+DEOTJTHb5IcvqFCKW7+U8PvxIex0cqxS/QcW4W4jZL4rhyqvhka2rtEx9izcHsC1krih7RLc5pK9jDxwBMXtqaRmKWB+KO6+JDsvyse3gCbGTH/Kou3WQBDssWMRBrgz6VkDAywER+SzZDamkuFmPFjWqJsgJn4XsIaNVsh+/4L0y3vbMwNCCZcsxZEwVr4K7JtZXzvClOhtTagY49M3VMcnaPU1gZM9QEpsLM24C22wgsU1gZYta1a2J8Wke4sOJqLDwZkpLkW6B+A3JkJtz0sRUxIpRwONxU/MGKNNEXHiAYUMYQ/I81QN2I1Rcebiw8GrFn2ZaiN/tn/DBO0v+XnUkcT3zOhjiS+RfviY6EBGXE+j4vY2r+BHJTcak3YxdZ7FmQ2lMiMsDIj3p4/B+S2p9EWj+WhpwbILBheVGpQJy0e6Qu2BsIh4Zp/RM4Jl1xrX0NLzEanJzRH+v0K/boeI70pj3R+1ltdDeSxtU6CXJFpdoAtMsPu6w9QyMJXsuxz+ICcJ8SvcS2QLTAPo0RKphtl+P2+3rLjOI7jOI7jOP8tH5ahgbeYuZE9AAAAAElFTkSuQmCC width=64 height=64></a>
<a href=https://linkedin.com/in/aadrake><img class=icon src=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAAzElEQVRIie2WWxGDMBBFVwISkIAEnBQJOCoOKqE4AAeNg+Lg9AOY2VmSTls29If7eTPJmbubl8gioAEG/DQAF9ECOkeA1VUnya1GgPEA0CARs2dO2QLBi2RBAShU78pcoF6MgCkH6AlUClJ7QGKgFXYD7l6QFOhbBeYN9Hb3bkCRHqX8CaiNV6aAe0CV9Ra/IHIsfgapRYuIv7lt9iTSi7VmbHP+9oB0eR6peR6gj+adoBP0X9ART/l43OdkiZnzu9XZmjb4lnFkTSIiLyov4WUSpGLDAAAAAElFTkSuQmCC width=64 height=64></a>
<a href=/index.xml><img class=icon src=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAABOElEQVRIib2WXXWEMBBGIyESkICDroPWQSNhHRQnrANwsOsAHFAJdXD7ALSz0wmZLrTfObwwkDs/X3ISwiIgAQPHaQBegxRwORCg1cpK/lopAKN6eQEaoAduwPsBoCFoSDAEVMDZSMotF0hBT8yV7gIBtMAb8Aw8ATEDTMDHHpClDm3VGVbjbKcXtGrSQCB6YL8FreoQLfXALJC099bPg4LVbMys6DpmazdOWHbzu+29AK0KO/Wdaf2SvaNaJGKfi0ntMxfIApcGP6mEflTudd0E1KqNWrKq86OgFSYr0wbplQMfBoEwC3ZVMpG7U98C3ZZFKmwHZRcDTjn3WaCqkPWLiPfemAWKBVCzMadszAJd+W7d1YjLOek9lY2ZnneoXR5vbPy/y0mmBUfqq50rLLHj8mFoRJwWnzknvtUm1yWnAAAAAElFTkSuQmCC width=64 height=64></a></div><div class=subscribe><form action=https://api.digitalmaneuver.com/subscribe method=get><input class=subscribe-field style=width:200px name=email placeholder=" Subscribe to newsletter? " type=text>
<input class=subscribe-btn value=Yes! type=submit></form></div></div></div><div class="container has-text-centered footer-copyright"></div></body>
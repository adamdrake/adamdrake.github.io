<!doctype html><html lang=en><head><meta charset=utf-8><meta name=mobile-web-app-capable content="yes"><meta name=viewport content="width=device-width,initial-scale=1"><title>An Unreasonably Deep Dive into Project Euler Problem 2 - Adam Drake</title><meta name=description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/data, leadership, and building tech teams."><link rel="shortcut icon" href=https://adamdrake.com/static/favicon.ico><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=me href=https://github.com/adamdrake><link rel=stylesheet href=https://adamdrake.com/css/style.min.css crossorigin=anonymous media=screen><meta property="og:url" content="https://adamdrake.com/"><meta property="og:title" content="Adam Drake"><meta property="og:site_name" content="Adam Drake"><meta property="og:type" content="website"><meta property="og:description" content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/data, leadership, and building tech teams."><meta name=twitter:title content="Adam Drake"><meta name=twitter:description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/data, leadership, and building tech teams."></head><body><header><section><div class="header flex row"><div class="header__item flex row"><a id=site__name href=https://adamdrake.com/>Adam Drake</a></div><div class="flex row"><nav aria-label="page menu" class="flex row"><ul role=menubar class="flex row"><li role=none><a class=sidebar-nav-itemmenu__item href=/ title>Latest</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/about.html title>About</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/cases.html title>Case Studies</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/contact.html title>Contact</a></li><li role=none><a class="sidebar-nav-item activemenu__item" href=/posts/index.html title=Posts>Posts</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/press.html title>Press</a></li><li><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button></li></ul></nav></div></div></section></header><main aria-role=main><section><ul id=feed__ul><li class="feed__li h-entry"><div class=feed__content><time class="hidden dt-published">2017-01-17 00:00:00 +0000 UTC</time><div class="flex properties__row"><div rel=author class="flex left p-author h-card"><img class=u-photo src=https://adamdrake.com/static/images/adam_drake_240.jpg alt="Adam Drake" id=author-img><div><p rel=me class=p-name id=author-name>Adam Drake</p><p class=properties>Jan 17, 2017</p></div></div><div class="flex right properties"></div></div><article class="md p-summary e-content"><h2 class=p-name>An Unreasonably Deep Dive into Project Euler Problem 2</h2><p>First, the problem definition:</p><blockquote><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &mldr;</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p></blockquote><p>Classic Fibonacci problem, with a slight twist due to the summation on top. Spoiler alert: a simple loop is fastest. Keep reading to see why.</p><h1 id=first-attempt-recursion class=anchor-link><a href=#first-attempt-recursion>First Attempt: Recursion</a></h1><p>The Fibonacci sequence is defined as f(n) = f(n-1) + f(n-2) where the first two elements are defined in this problem as f(1) = 1 and f(2) = 2.</p><p>This means</p><p>f(3) = f(2) + f(1) = 2 + 1 = 3,</p><p>f(4) = f(3) + f(2) = 3 + 2 = 5,</p><p>and so on.</p><p>This recursive definition translates easily into most programming languages although, as we&rsquo;ll see, the performance isn&rsquo;t the best.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fibsRecursion</span>(<span style=color:#a6e22e>limit</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>limit</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>limit</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fibsRecursion</span>(<span style=color:#a6e22e>limit</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>fibsRecursion</span>(<span style=color:#a6e22e>limit</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function takes an input <code>limit</code> and will generate the nth Fibonacci number. The function alone doesn&rsquo;t solve our problem, because we still need to calculate the whole sequence of numbers, check if each is even, and add the even ones to the sum. We can wrap that functionality in a small <code>for</code> loop.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sumEvenFibsRecursion</span>(<span style=color:#a6e22e>limit</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>next</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>next</span> &lt; <span style=color:#a6e22e>limit</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>next</span> = <span style=color:#a6e22e>fibsRecursion</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEven</span>(<span style=color:#a6e22e>next</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>next</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Where <code>isEven</code> is a small helper function to cut down on typing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isEven</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Mod</span>(float64(<span style=color:#a6e22e>x</span>), <span style=color:#ae81ff>2</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Ok, now we can calculate Fibonacci numbers, iterate up to a limit, check if they are even, and sum them. There are also tests and a benchmark, for completeness.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>LIMIT</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>3999999</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>SUM_LIMIT</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>4613732</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestIsEven</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>isEven</span>(<span style=color:#ae81ff>4</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>true</span>) <span style=color:#f92672>||</span> (<span style=color:#a6e22e>isEven</span>(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;isEven returned incorrect value&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestFibsRecursion</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>firstTen</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>21</span>, <span style=color:#ae81ff>34</span>, <span style=color:#ae81ff>55</span>, <span style=color:#ae81ff>89</span>}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>firstTen</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fib</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fibsRecursion</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fib</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>v</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;recursion gave&#34;</span>, <span style=color:#a6e22e>fib</span>, <span style=color:#e6db74>&#34;want&#34;</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestSumEvenFibsRecursion</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sumEvenFibsRecursion</span>(<span style=color:#a6e22e>LIMIT</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>SUM_LIMIT</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;wanted&#34;</span>, <span style=color:#a6e22e>SUM_LIMIT</span>, <span style=color:#e6db74>&#34;got&#34;</span>, <span style=color:#a6e22e>result</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSumEvenFibsRecursion</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumEvenFibsRecursion</span>(<span style=color:#a6e22e>LIMIT</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can run the tests and see that everything passes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestIsEven
</span></span><span style=display:flex><span>--- PASS: TestIsEven <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestFibsRecursion
</span></span><span style=display:flex><span>--- PASS: TestFibsRecursion <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestSumEvenFibsRecursion
</span></span><span style=display:flex><span>--- PASS: TestSumEvenFibsRecursion <span style=color:#f92672>(</span>0.05s<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Now on to the benchmark so we can look at the performance characteristics of this approach.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>BenchmarkSumEvenFibsRecursion-4               <span style=color:#ae81ff>30</span>          <span style=color:#ae81ff>46091679</span> ns/op
</span></span></code></pre></div><p>That is extremely slow, as expected. The recursive approach is doing a ton of unnecessary work. Additionally, <a href=https://en.wikipedia.org/wiki/Tail_call>tail-call optimization</a> is not always supported in Go, at least there was no <a href=https://groups.google.com/forum/#!msg/golang-nuts/0oIZPHhrDzY/2nCpUZDKZAAJ>plan to implement TCO more broadly</a>, which also can result in memory usage or performance characteristics that are difficult to analyze or plan for.</p><p>From a time and space complexity perspective, we can think of the space complexity first. There will be a function call, recursively, for each Fibonacci number calculated. So if we want the first 5 numbers, we&rsquo;ll have 5 function calls on the stack. The depth of the stack is <code>O(n)</code> and memory requirement will be <code>N * frameSize</code>, where frameSize is the size of the frame inserted into the stack with each function call.</p><p>On the time complexity side, the short version is the bound on time complexity is <code>O(2^n)</code>.</p><p>The slightly longer version is that the tight bound is <code>O(Phi^n)</code> where <code>Phi</code> is the so-called <em>golden ratio</em> 1.618&mldr; and <code>n</code> is the nth Fibonacci number. In other words, it&rsquo;s still exponential but with a slightly smaller base. To see why, consider that the recurrence relation use to generate the sequence is proportional to the time complexity required to calculated it. At that point you can use the closed-form approximation for the Fibonacci sequence numbers themselves. Since the numbers in the sequence grow as <code>O(Phi)</code> then the time complexity grows that way too.</p><h1 id=second-attempt-iteration class=anchor-link><a href=#second-attempt-iteration>Second Attempt: Iteration</a></h1><p>In the recursive case, we were recalculating the Fibonacci numbers all the time, which leads to a lot of wasted computation. Consider that for computing <code>F(4)</code> (the fourth Fibonacci number) we would compute <code>F(3) + F(2) + F(1)</code>, but we already have <code>F(2) and F(1)</code> when we computed <code>F(3)</code>, so why computer them again? Instead of starting from a limit and calling functions all the way down as our recursive function did, we can simply build up the list of Fibonacci numbers from the bottom. This allows us to use numbers already calculated to calculate the next number in the sequence.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sumEvenFibsSlice</span>(<span style=color:#a6e22e>limit</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fibs</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>newElement</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>; <span style=color:#a6e22e>newElement</span> &lt; <span style=color:#a6e22e>limit</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>newElement</span> = <span style=color:#a6e22e>fibs</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#a6e22e>fibs</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fibs</span> = append(<span style=color:#a6e22e>fibs</span>, <span style=color:#a6e22e>newElement</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sumEvens</span>(<span style=color:#a6e22e>fibs</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this example, we start with a slice that has the first two numbers as given in the problem, and then appends the remaining numbers onto the slice until the new element in the sequence is greater than or equal to the limit, at which point we return the sum of the even numbers in the slice.</p><p>We can write the test and benchmark code as before.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestSumEvenFibsSlice</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sumEvenFibsSlice</span>(<span style=color:#a6e22e>LIMIT</span>) <span style=color:#f92672>!=</span> <span style=color:#a6e22e>SUM_LIMIT</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSumEvenFibsSlice</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumEvenFibsSlice</span>(<span style=color:#a6e22e>LIMIT</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Which gives us passing tests and a new benchmark number.</p><pre tabindex=0><code>BenchmarkSumEvenFibsSlice-4               200000              6210 ns/op
</code></pre><p>This is a faster approach compared to the recursive solution, by a lot. In fact the recursive solution takes about 7400 times longer, so we&rsquo;re on the right track.</p><p>Now that we have an iterative solution, many newcomers to Go will think that it makes sense to spin off a thread/goroutine to do the calculations and pass the results back over a channel for our function to use.</p><h1 id=winner-a-simple-loop class=anchor-link><a href=#winner-a-simple-loop>Winner: a simple loop</a></h1><p>Slices perform acceptably, but they&rsquo;re still relatively slow. We can do better by using a simple loop and accumulating our sum along the way. The code starts index <code>i</code> and <code>j</code> at 1, and adds and swaps them until the limit is reached. The benefit of this approach is that we are only using a few integer values, and we are only iterating until we reach the limit, so this approach is linear for our values.</p><p><strong>NOTE</strong> that there is a caveat here as we are dealing with values which fit into a normal <code>int</code> type in Go. If the integers become too big and we need to use arbitrarily-large integers, we will have different performance characteristics. For our purposes though, the simple looping approach has <code>O(n)</code> time complexity.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sumEvenFibsLoop</span>(<span style=color:#a6e22e>limit</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>j</span> &lt; <span style=color:#a6e22e>limit</span>; <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>i</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEven</span>(<span style=color:#a6e22e>i</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Test and benchmark:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestSumEvenFibsLoop</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sumEvenFibsLoop</span>(<span style=color:#a6e22e>LIMIT</span>) <span style=color:#f92672>!=</span> <span style=color:#a6e22e>SUM_LIMIT</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;sumevenfibloop&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSumEvenFibsLoop</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumEvenFibsLoop</span>(<span style=color:#a6e22e>LIMIT</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>BenchmarkSumEvenFibsLoop-4                300000              5535 ns/op
</code></pre><p>The performance of this approach is the best so far, but just barely. It outperforms the slice approach, but not by much.</p><h1 id=digression-channels class=anchor-link><a href=#digression-channels>Digression: Channels</a></h1><p>A common thing newcomers do when they pick up Go is they reach for channels and goroutines. Although these are awesome tools and it&rsquo;s great they are so easy to use in the language, they aren&rsquo;t always good for performance. The short reason is that channels are essentially a mutable data structure, and therefore require locks. Locks are an enemy of performance, so in many tasks you will slow down your computations if you use channels and goroutines.</p><p>For example, we can use the standard approach of creating a function which returns a channel of values. We&rsquo;ll drop our iterative solution from before into a function which is spun off as its own goroutine.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fibsChannel</span>(<span style=color:#a6e22e>limit</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>output</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> close(<span style=color:#a6e22e>output</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>j</span> &lt; <span style=color:#a6e22e>limit</span>; <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>i</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>output</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>output</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can use this for our specific problem in the following way.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sumEvenFibsChannel</span>(<span style=color:#a6e22e>limit</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fibs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fibsChannel</span>(<span style=color:#a6e22e>limit</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>fibs</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEven</span>(<span style=color:#a6e22e>f</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>f</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>along with the accompanying tests and benchmarks.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestFibsChannel</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>firstTen</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>21</span>, <span style=color:#ae81ff>34</span>, <span style=color:#ae81ff>55</span>, <span style=color:#ae81ff>89</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fibs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fibsChannel</span>(<span style=color:#ae81ff>90</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>firstTen</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>chanVal</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>fibs</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>chanVal</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;fibChannel incorrect.  Expected&#34;</span>, <span style=color:#a6e22e>v</span>, <span style=color:#e6db74>&#34;but received&#34;</span>, <span style=color:#a6e22e>chanVal</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestSumEvenFibsChannel</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sumEvenFibsChannel</span>(<span style=color:#a6e22e>LIMIT</span>) <span style=color:#f92672>!=</span> <span style=color:#a6e22e>SUM_LIMIT</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSumEvenFibsChannel</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumEvenFibsChannel</span>(<span style=color:#a6e22e>LIMIT</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>All the tests pass, and we can get a look at the performance of the channels approach.</p><pre tabindex=0><code>BenchmarkSumEvenFibsChannel-4             100000             18677 ns/op
</code></pre><p>At 18,677 ns/op the channels approach takes around 3 times as long as the slices approach, and about 3.4 times as long as the simple loop, so although channels and goroutines are a wonderful part of the language, they are not a good fit for all problems.</p><h1 id=digression-solution-by-approximation class=anchor-link><a href=#digression-solution-by-approximation>Digression: Solution by approximation</a></h1><p>It was briefly mentioned earlier that the runtime complexity of the recursive solution is <code>O(Phi^n)</code> where <code>Phi</code> is the <a href=https://en.wikipedia.org/wiki/Golden_ratio#Relationship_to_Fibonacci_sequence>Golden Ratio</a>. With some further analysis you can show that the Nth Fibonacci number can be approximated by <code>1/sqrt(5) * Phi^(n+1)</code>. We can use this method to generate our Fibonacci numbers as well.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fibApprox</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fib</span> <span style=color:#f92672>:=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Sqrt</span>(<span style=color:#ae81ff>5</span>)) <span style=color:#f92672>*</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Pow</span>(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Phi</span>, float64(<span style=color:#a6e22e>n</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(<span style=color:#a6e22e>fib</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>) <span style=color:#75715e>//  BUG: This only works for postive numbers</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestFibApprox</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>firstTen</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>21</span>, <span style=color:#ae81ff>34</span>, <span style=color:#ae81ff>55</span>, <span style=color:#ae81ff>89</span>}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>firstTen</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fib</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fibApprox</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fib</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>v</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;got&#34;</span>, <span style=color:#a6e22e>fib</span>, <span style=color:#e6db74>&#34;want&#34;</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestSumEvenFibsApprox</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sumEvenFibsApprox</span>(<span style=color:#a6e22e>LIMIT</span>) <span style=color:#f92672>!=</span> <span style=color:#a6e22e>SUM_LIMIT</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSumEvenFibsApprox</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumEvenFibsApprox</span>(<span style=color:#a6e22e>LIMIT</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, although we have a closed-form solution it is not yet faster than our simple loop implementation.</p><pre tabindex=0><code>BenchmarkSumEvenFibsApprox-4              200000              7769 ns/op
</code></pre><p>Part of the reason for this is because for the numbers we&rsquo;re dealing with, which fit into 64 bit integers, the simple loop has an apparently linear time complexity. However, once we get into arbitrarily large numbers and need something from <code>math/big</code> then we won&rsquo;t have the same performance characteristics and the closed-form solution may be faster, even though it does contain exponentiation. Recall that <a href=https://en.wikipedia.org/wiki/Exponentiation_by_squaring>exponentiation by squaring</a> has a computational complexity of about <code>O(log n)</code>.</p><h1 id=bonus-round-bitwise-and-for-evenodd-checking class=anchor-link><a href=#bonus-round-bitwise-and-for-evenodd-checking>Bonus Round: Bitwise and for even/odd checking</a></h1><p>Although the fastest approach we tested was the simple loop, we were still using the <code>isEven()</code> function, which used modular arithmetic to tell us if the integer was even or not. I also wanted to check to see if there would be a significant speedup from switching to <a href=https://en.wikipedia.org/wiki/Bitwise_operation#AND>bitwise operations</a> to check the <a href=https://en.wikipedia.org/wiki/Parity_(mathematics)>parity</a> of the numbers.</p><p>The short version is that replacing the <code>math.Mod()</code> call with a bitwise <code>and</code>, we can determine the parity of the number in a much more computationally-efficient way.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isEven</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I had benchmarks for <code>isEven()</code> before and after.</p><p>Before:</p><pre tabindex=0><code>BenchmarkIsEvenEven-4                   30000000                43.5 ns/op
BenchmarkIsEvenOdd-4                    30000000                44.8 ns/op
</code></pre><p>After:</p><pre tabindex=0><code>BenchmarkIsEvenEven-4                   2000000000               0.34 ns/op
BenchmarkIsEvenOdd-4                    2000000000               0.34 ns/op
</code></pre><p>This is a performance improvement of <strong>130 times</strong>.</p><p>When we use this bitwise version for the parity checking in the other algorithms, we see the expected speedups.</p><pre tabindex=0><code>BenchmarkSumEvenFibsSlice-4              3000000               455 ns/op
BenchmarkSumEvenFibsRecursion-4               30          46208502 ns/op
BenchmarkSumEvenFibsLoop-4              30000000                49.7 ns/op
BenchmarkSumEvenFibsChannel-4             100000             11670 ns/op
BenchmarkSumEvenFibsApprox-4             1000000              1766 ns/op
</code></pre><p>If we wanted to further speed up the simple loop, we could remove the overhead of the function call to <code>isEven()</code> and inline the bitwise and.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sumEvenFibsLoop</span>(<span style=color:#a6e22e>limit</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>j</span> &lt; <span style=color:#a6e22e>limit</span>; <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>i</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Which cuts off a bit more time, about 11%.</p><pre tabindex=0><code>BenchmarkSumEvenFibsLoop-4      30000000                44.0 ns/op
</code></pre><h1 id=conclusion class=anchor-link><a href=#conclusion>Conclusion</a></h1><p>Project Euler problems, in addition to fun programming exercises, can be great ways to refresh mathematics and computer science skills you may have forgotten or may not have used in a while. For this problem alone we got into time and memory complexity, recurence relations, recursion, channels and goroutines, bitwise operations, and testing and benchmarking in Go.</p><p>We could have gone further down the rabbit hole, especially on the mathematics side of things, but then it would be <a href=https://en.wikipedia.org/wiki/Turtles_all_the_way_down>turtles all the way down</a> and we wouldn&rsquo;t be able to move on to other problems.</p><a class=hidden href=https://brid.gy/publish/mastodon></a><a class=hidden href=https://brid.gy/publish/twitter></a><a class=hidden href=https://fed.brid.gy/></a><data class=p-bridgy-omit-link value=false></data></article></div><div id=webmentions></div></li></ul></section></main><hr><footer class="flex col"><section class="footer-bio content"><p><strong>Adam Drake</strong> leads technical business transformations in global and multi-cultural environments. He has a passion for helping companies become more productive by improving internal leadership capabilities, and accelerating product development through technology and data architecture guidance. Adam has served as a White House Presidential Innovation Fellow and is an IEEE Senior Member.</p></section><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button><div class=social-icons><a rel=me href=https://github.com/adamdrake title=GitHub><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></body></html>
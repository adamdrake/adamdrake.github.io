<!doctype html><html lang=en><head><meta charset=utf-8><meta name=mobile-web-app-capable content="yes"><meta name=viewport content="width=device-width,initial-scale=1"><title>An Unreasonably Deep Dive into Project Euler Problem 1 - Adam Drake</title><meta name=description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/data, leadership, and building tech teams."><link rel="shortcut icon" href=https://adamdrake.com/static/favicon.ico><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=me href=https://github.com/adamdrake><link rel=stylesheet href=https://adamdrake.com/css/style.min.css crossorigin=anonymous media=screen><meta property="og:url" content="https://adamdrake.com/"><meta property="og:title" content="Adam Drake"><meta property="og:site_name" content="Adam Drake"><meta property="og:type" content="website"><meta property="og:description" content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/data, leadership, and building tech teams."><meta name=twitter:title content="Adam Drake"><meta name=twitter:description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/data, leadership, and building tech teams."></head><body><header><section><div class="header flex row"><div class="header__item flex row"><a id=site__name href=https://adamdrake.com/>Adam Drake</a></div><div class="flex row"><nav aria-label="page menu" class="flex row"><ul role=menubar class="flex row"><li role=none><a class=sidebar-nav-itemmenu__item href=/ title>Latest</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/about.html title>About</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/cases.html title>Case Studies</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/contact.html title>Contact</a></li><li role=none><a class="sidebar-nav-item activemenu__item" href=/posts/index.html title=Posts>Posts</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/press.html title>Press</a></li><li><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button></li></ul></nav></div></div></section></header><main aria-role=main><section><ul id=feed__ul><li class="feed__li h-entry"><div class=feed__content><time class="hidden dt-published">2017-01-04 00:00:00 +0000 UTC</time><div class="flex properties__row"><div rel=author class="flex left p-author h-card"><img class=u-photo src=https://adamdrake.com/static/images/adam_drake_240.jpg alt="Adam Drake" id=author-img><div><p rel=me class=p-name id=author-name>Adam Drake</p><p class=properties>Jan 04, 2017</p></div></div><div class="flex right properties"></div></div><article class="md p-summary e-content"><h2 class=p-name>An Unreasonably Deep Dive into Project Euler Problem 1</h2><h1 id=introduction class=anchor-link><a href=#introduction>Introduction</a></h1><p>As part of my work in keeping my technical skills sharp, I periodically go back to basics or solve old problems again in order to ensure my foundations are strong. So it was with great fun that I decided to start back at the beginning with <a href=https://projecteuler.net>Project Euler</a>.</p><p>One of the techniques I also use for this sort of thing is not just to solve the problem, but to really explore it. Write additional code, tests, benchmarks, and explore the underlying mathematics where practical.</p><p>With that in mind, here is a deep dive into <a href="https://projecteuler.net/problem=1">Project Euler - Problem 1</a>.</p><h1 id=overview class=anchor-link><a href=#overview>Overview</a></h1><p>The problem is short and easy to understand:</p><blockquote><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.</p></blockquote><p>A simple brute-force approach to this is simply to iterate through all of the numbers from 1 to 999 (since we are only to check numbers below 1000), check if the number is divisible by 3 or 5, and sum the ones which are.</p><p>If you want the Python one-liner:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>sum([x <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1000</span>) <span style=color:#66d9ef>if</span> ((x <span style=color:#f92672>%</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>or</span> (x <span style=color:#f92672>%</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>))])
</span></span></code></pre></div><p>Of if you are using Go, as I was:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>bruteForce</span>(<span style=color:#a6e22e>limit</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>total</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>limit</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Mod</span>(float64(<span style=color:#a6e22e>i</span>), <span style=color:#ae81ff>5</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Mod</span>(float64(<span style=color:#a6e22e>i</span>), <span style=color:#ae81ff>3</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>total</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>total</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=does-it-work class=anchor-link><a href=#does-it-work>Does it work?</a></h1><p>This works fine and both produce the required answer of 233168, which we can verify with some tests in Go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestBruteForce</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bruteForce</span>(<span style=color:#ae81ff>9</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>23</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;The sum of values from 1 to 10 which are divisible by 5 and 3 should be 23&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bruteForce</span>(<span style=color:#ae81ff>999</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>233168</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;The sum of values from 1 to 1000 which are divisible by 5 and 3 should be 233168&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And we can run the tests to ensure that everything passes and is working normally.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go test -v
</span></span><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestBruteForce
</span></span><span style=display:flex><span>--- PASS: TestBruteForce <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok      _path/...     0.008s
</span></span></code></pre></div><h1 id=how-fast-is-it class=anchor-link><a href=#how-fast-is-it>How fast is it?</a></h1><p>This is enough for a working solution, and it isn&rsquo;t too slow, but it&rsquo;s not great as we can see by the built-in benchmark capabilities in Go.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkBruteForce</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>bruteForce</span>(<span style=color:#ae81ff>999</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A benchmark function takes a <code>*testing.B</code> and iterates up to <code>b.N</code>, which is a number defined by the package and dependent on the stability of the timing of your function call, and produces output telling you how many times the function was run in order to perform the benchmark provide the required execution time per call.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go test -bench .
</span></span><span style=display:flex><span>BenchmarkBruteForce-4              <span style=color:#ae81ff>10000</span>            <span style=color:#ae81ff>227761</span> ns/op
</span></span></code></pre></div><p>So our brute force approach took 10000 iterations to settle on a timing of 227,761 nanoseconds per operation.</p><p>Now we have not only solved the problem, but added tests and benchmarks. Perhaps a bit more effort than some people put into Project Euler, but not bad. However, this solution is still linear in the number of elements we have to check. In other words, if we wanted to check the numbers up to 1,000,000 instead of only up to 1,000 then the solution would take much longer to run. This solution is O(n) which isn&rsquo;t bad, but isn&rsquo;t great either. We check the increase in runtime by simply modifying the argument in our benchmark function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkBruteForce</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>bruteForce</span>(<span style=color:#ae81ff>1000000</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we will have different timing and benchmark information.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go test -bench .
</span></span><span style=display:flex><span>BenchmarkBruteForce-4                  <span style=color:#ae81ff>3</span>         <span style=color:#ae81ff>441286594</span> ns/op
</span></span></code></pre></div><p>So by increasing the numbers we have to check by a factor of 1000, we now have a runtime of 441,286,594 ns/op instead of 227,761 ns/op, which is an increase of about 1900x. Not good. For more on asymptotic analysis of runtime, check out the Wikipedia article on <a href=https://en.wikipedia.org/wiki/Big_O_notation>Big O Notation</a>.</p><h1 id=performance-upgrades class=anchor-link><a href=#performance-upgrades>Performance upgrades</a></h1><p>There are some options to improve the performance, like splitting the range of numbers into parts and spawning multiple worker threads to check each part, thereby parallelizing the work. This is a lot of complexity though, especially when you want to make sure that ranges checked don&rsquo;t overlap, managing potential shared state, and so on. If we think a bit more about the problem, there is a better way.</p><p>We want to sum all the multiples of 3 or 5 less than 1000. We can think about the sequence of multiples of 3 as (3, 6, 9, 12, 15, &mldr;, 999), which is the same as 3 * (1, 2, 3, 4, 5, &mldr;, 333). We can do the same for the case of multiples of 5. The benefit of considering the problem in this way is that the list of numbers has a closed-form solution (i.e., a formula) for calculating the sum.</p><p>Such a sequence, where the difference between each number is constant, is called a <a href=https://en.wikipedia.org/wiki/Arithmetic_progression>finite arithmetic progression</a> or finite arithmetic sequence and the sum of a finite arithmetic progression is called a finite arithmetic series. The formula for the sum is <code>1/2 * n * (a_1 + a_n)</code>. where <code>n</code> is the number of terms being added, <code>a_1</code> is the first element in the sequence, and <code>a_n</code> is the last element in the sequence.</p><p>From our example for multiples of 3, we know that <code>a_1 = 1</code> and we know that <code>a_n = floor(999/3) = 333</code> and we also know that the total number of elements in the sequence will be <code>n = floor(999/3) = 333 = a_n</code>. So for our purposes, the sum of our sequences is equal to <code>n * (n + 1) * 0.5</code>. We can make a small helper function to calculate this for us.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>arithSum</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>float64</span>) <span style=color:#66d9ef>float64</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we can simply compute the sum of the arithmetic sequence for all the multiples of 3 and 5 without iterating through anything at all. Since we already know the answers to the questions from the brute force case, we can also write the appropriate tests.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestArithSeq</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>arithSeq</span>(<span style=color:#ae81ff>9</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>23</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;The sum of values from 1 to 10 which are divisible by 5 and 3 should be 23&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>arithSeq</span>(<span style=color:#ae81ff>999</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>233168</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;The sum of values from 1 to 1000 which are divisible by 5 and 3 should be 233168&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For the corresponding function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>arithSeq</span>(<span style=color:#a6e22e>limit</span> <span style=color:#66d9ef>float64</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>threes</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>arithSum</span>(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Floor</span>((<span style=color:#a6e22e>limit</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fives</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>arithSum</span>(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Floor</span>((<span style=color:#a6e22e>limit</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> int(<span style=color:#a6e22e>threes</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>fives</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But there is a problem because not all of our tests pass.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go test -v
</span></span><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestArithSeq
</span></span><span style=display:flex><span>--- FAIL: TestArithSeq <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>		0001_test.go:10: The sum of values from <span style=color:#ae81ff>1</span> to <span style=color:#ae81ff>1000</span> which are divisible by <span style=color:#ae81ff>5</span> and <span style=color:#ae81ff>3</span> should be 233168
</span></span><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestBruteForce
</span></span><span style=display:flex><span>--- PASS: TestBruteForce <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>FAIL
</span></span><span style=display:flex><span>exit status <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>What is the problem? Why did the test for <code>n = 9</code> pass but the test for <code>n = 999</code> fail? The answer starts at 15, which is divisible by both 5 <strong>and</strong> 3. Because we summed all the multiple of 5, and all the multiples of 3, we also summed all the multiples of 15. In other words, all the multiples of 15 are double counted because we need them to be summed as a multiple of 5, or as a multiple of 3, but not both. This a common problem in combinatorics, the study of finite or countable discrete structures, and the answer is easily described by the <a href=https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle>inclusion-exclusion principle</a>.</p><p>For some set <code>A</code>, like the set of all multiples of 3, and some set <code>B</code>, like the set of all multiples of 5, then when we add them we have to subtract their interaction because it is counted twice. In our case, this intersection is the set of all multiples of 15. So we can get the correct solution by simply removing the sum of all multiples of 15 from our total.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>arithSeq</span>(<span style=color:#a6e22e>limit</span> <span style=color:#66d9ef>float64</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>threes</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>arithSum</span>(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Floor</span>(<span style=color:#a6e22e>limit</span><span style=color:#f92672>-/</span><span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fives</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>arithSum</span>(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Floor</span>(<span style=color:#a6e22e>limit</span><span style=color:#f92672>/</span><span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fifteens</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>15</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>arithSum</span>(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Floor</span>(<span style=color:#a6e22e>limit</span><span style=color:#f92672>/</span><span style=color:#ae81ff>15</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> int(<span style=color:#a6e22e>threes</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>fives</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>fifteens</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now all of our tests will pass.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go test -v
</span></span><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestArithSeq
</span></span><span style=display:flex><span>--- PASS: TestArithSeq <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>===</span> RUN   TestBruteForce
</span></span><span style=display:flex><span>--- PASS: TestBruteForce <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>PASS
</span></span></code></pre></div><p>Ok, great. Now we have another way of solving the problem, but what was the actual speed benefit? It&rsquo;s pretty dramatic. First, we need to add a benchmark function to our <code>_test.go</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkArithSeq</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>arithSeq</span>(<span style=color:#ae81ff>999</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we can see the difference.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go test -bench .
</span></span><span style=display:flex><span>BenchmarkBruteForce-4              <span style=color:#ae81ff>10000</span>            <span style=color:#ae81ff>227689</span> ns/op
</span></span><span style=display:flex><span>BenchmarkArithSeq-4             <span style=color:#ae81ff>100000000</span>               21.8 ns/op
</span></span><span style=display:flex><span>PASS
</span></span></code></pre></div><p>Both of those are for the specified Project Euler problem of summing only the multiples below 1000. In this case, the solution using the arithmetic series approach is about 10,000 times faster than the brute-force approach.</p><p>Better still, because the arithmetic series approach requires the same number of operations regardless of the input size, it doesn&rsquo;t matter if we want to do the summation for multiples up to 1000 or 1,000,000 it will always take the same amount of processing time. So the arithmetic series approach is constant time (also denoted O(1)). Much better.</p><p>There are probably other interesting ways to solve this problem, like finding the prime factors of all the numbers less than <code>n</code> to see if 3 or 5 is one of the factors, but I think this is enough for now.</p><a class=hidden href=https://brid.gy/publish/mastodon></a><a class=hidden href=https://brid.gy/publish/twitter></a><a class=hidden href=https://fed.brid.gy/></a><data class=p-bridgy-omit-link value=false></data></article></div><div id=webmentions></div></li></ul></section></main><hr><footer class="flex col"><section class="footer-bio content"><p><strong>Adam Drake</strong> leads technical business transformations in global and multi-cultural environments. He has a passion for helping companies become more productive by improving internal leadership capabilities, and accelerating product development through technology and data architecture guidance. Adam has served as a White House Presidential Innovation Fellow and is an IEEE Senior Member.</p></section><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button><div class=social-icons><a rel=me href=https://github.com/adamdrake title=GitHub><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></body></html>
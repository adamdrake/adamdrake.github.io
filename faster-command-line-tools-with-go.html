<!doctype html><html lang=en><head><meta charset=utf-8><meta name=mobile-web-app-capable content="yes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Faster command line tools with Go - Adam Drake</title><meta name=description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/crypto/data, leadership, and building tech teams."><link rel="shortcut icon" href=https://adamdrake.com/static/favicon.ico><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=me href=https://github.com/adamdrake><link rel=me href=https://twitter.com/aadrake><link rel=stylesheet href=https://adamdrake.com/css/style.min.css crossorigin=anonymous media=screen><meta property="og:url" content="https://adamdrake.com"><meta property="og:title" content="Adam Drake"><meta property="og:site_name" content="Adam Drake"><meta property="og:type" content="website"><meta property="og:description" content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/crypto/data, leadership, and building tech teams."><meta property="og:image" content="/static/images/twitter-card.jpg"><meta name=twitter:title content="Adam Drake"><meta name=twitter:description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/crypto/data, leadership, and building tech teams."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/static/images/twitter-card.jpg"></head><body><header><section><div class="header flex row"><div class="header__item flex row"><a id=site__name href=https://adamdrake.com>Adam Drake</a></div><div class="flex row"><nav aria-label="page menu" class="flex row"><ul role=menubar class="flex row"><li role=none><a class=sidebar-nav-itemmenu__item href=/ title>Latest</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/about.html title>About</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/cases.html title>Case Studies</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/contact.html title>Contact</a></li><li role=none><a class="sidebar-nav-item activemenu__item" href=/posts.html title=Posts>Posts</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/press.html title>Press</a></li><li><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button></li></ul></nav></div></div></section></header><main aria-role=main><section><ul id=feed__ul><li class="feed__li h-entry"><div class=feed__content><time class="hidden dt-published">2017-05-29 00:00:00 +0000 UTC</time><div class="flex properties__row"><div rel=author class="flex left p-author h-card hidden"><img class=u-photo src=https://adamdrake.com/static/images/adam_drake_240.jpg alt="Adam Drake" id=author-img><div><p rel=me class=p-name id=author-name>Adam Drake</p><p class=properties>May 29, 2017</p></div></div><div class="flex right properties"></div></div><article class="md p-summary e-content"><h1 class=p-name>Faster command line tools with Go</h1><h1 id=update class=anchor-link><a href=#update>Update</a></h1><p>After some input from u/epiris on Reddit, I improved the code a bit further by changing the way bytestreams are scanned. Current fastest runtime is 0.308s for 10,512,769 rows, or about 34 Million rows per second. Since the file is 184 Megabytes, this is a processing speed of about 600 Megabytes per second, which is probably close to the read speed limit of my SSD.</p><hr><p>It all started with a blog post, <a href=https://dlang.org/blog/2017/05/24/faster-command-line-tools-in-d/>Faster Command Line Tools in D</a>. It was at the top of <a href=https://news.ycombinator.com>Hacker News</a> and got picked up by other sites as well. Then Euan Torano wrote <a href=https://www.euantorano.co.uk/posts/faster-command-line-tools-in-nim/>Faster Command Line Tools in Nim</a>. After reading about both, I found some comments in the <a href=https://www.reddit.com/r/golang/comments/6dhbwv/faster_command_line_tools_in_golang/>Reddit post</a> on the same topic, but in Go. Go is a great tool for many things, but I wasn&rsquo;t sure what kind of performance I&rsquo;d get out of this kind of tool.</p><p><strong>TL;DR</strong>: I wrote a special-case version of the utility which processes the input in about 0.482 seconds, or about 22.8 million lines per second on my laptop, which is a processing rate of about 390 Megabytes per second.</p><p>The approximate performance of the other languages was as follows:</p><ul><li><p>Python: 15 seconds</p></li><li><p>D (DMD): 2.4 seconds</p></li><li><p>D (LDC): 1.4 seconds</p></li><li><p>Nim: 1.4 seconds</p></li><li><p>My current-fastest Go version: 0.338s</p></li></ul><h1 id=problem-statement class=anchor-link><a href=#problem-statement>Problem statement</a></h1><p>The original version of the problem, as outlined in the post on D, was the following:</p><blockquote><p>It’s a common programming task: Take a data file with fields separated by a delimiter (comma, tab, etc), and run a mathematical calculation involving several of the fields. Often these programs are one-time use scripts, other times they have longer shelf life. Speed is of course appreciated when the program is used more than a few times on large files.</p><p>The specific exercise we’ll explore starts with files having keys in one field, integer values in another.
&mldr;
Fields are delimited by a TAB, and there may be any number of fields on a line. The file name and field numbers of the key and value are passed as command line arguments.</p></blockquote><p>Okay. We&rsquo;ll have a delimited file (with tabs in this case), and we want to provide the filename, index for the key column, and index for the value column to our code. With those, our code should compute the sum of all the values for each specific key, and then output the key having the largest value. In SQL terms, this is a <code>GROUP BY</code> and a <code>MAX</code>. (Note that I did not do a version of this problem in SQL, but from what I&rsquo;ve seen it is slower than the Go/Nim/D versions, though perhaps not the Python version.)</p><p>The data we will use is a <a href=https://storage.googleapis.com/books/ngrams/books/googlebooks-eng-all-1gram-20120701-0.gz>file of n-grams</a> from the Google Books dataset. The file is 184 Megabytes, uncompressed, and has a total of 10,512,769 lines.</p><h1 id=first-attempt class=anchor-link><a href=#first-attempt>First attempt</a></h1><p>As a first try, we&rsquo;ll use all the built-in Go libraries for string and file processing. We&rsquo;ll keep the code general and high-level, and see what kind of speed we get.</p><p>Since I like to start with data structures, we&rsquo;ll just use a simple <code>map[string]int</code> in this case, with the string keys being the keys from our file, and the integer values being the sum of all the values in the file for that particular key. In other words, it&rsquo;s a <code>for</code> loop over the rows in the file, and an increment of a map value each time we go through the loop. Then at the end we&rsquo;ll do a for loop over all the elements in the map and see which key has the largest value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;bufio&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;flag&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;math&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;strconv&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>processFile</span>(<span style=color:#a6e22e>filePath</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>keyIndex</span>, <span style=color:#a6e22e>valueIndex</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>delim</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;\t&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fileHandle</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>filePath</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fileHandle</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>maxFieldIndex</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Max</span>(float64(<span style=color:#a6e22e>keyIndex</span>), float64(<span style=color:#a6e22e>valueIndex</span>)))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sumByKey</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fileReader</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewScanner</span>(<span style=color:#a6e22e>fileHandle</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>fileReader</span>.<span style=color:#a6e22e>Scan</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fields</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>TrimSpace</span>(<span style=color:#a6e22e>fileReader</span>.<span style=color:#a6e22e>Text</span>()), <span style=color:#a6e22e>delim</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>maxFieldIndex</span> &lt; len(<span style=color:#a6e22e>fields</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Atoi</span>(<span style=color:#a6e22e>fields</span>[<span style=color:#a6e22e>valueIndex</span>])
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sumByKey</span>[<span style=color:#a6e22e>fields</span>[<span style=color:#a6e22e>keyIndex</span>]] <span style=color:#f92672>+=</span> <span style=color:#a6e22e>value</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>maxValue</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>maxKey</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>sumByKey</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> &gt; <span style=color:#a6e22e>maxValue</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>maxValue</span> = <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>maxKey</span> = <span style=color:#a6e22e>k</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;max_key:&#34;</span>, <span style=color:#a6e22e>maxKey</span>, <span style=color:#e6db74>&#34;sum:&#34;</span>, <span style=color:#a6e22e>sumByKey</span>[<span style=color:#a6e22e>maxKey</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>filePath</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;filePath&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;Name of the file to parse&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>keyIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>Int</span>(<span style=color:#e6db74>&#34;keyIndex&#34;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Index of key (0 is first position)&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>valueIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>Int</span>(<span style=color:#e6db74>&#34;valueIndex&#34;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Index of value (0 is first position)&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>Parse</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>processFile</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>filePath</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>keyIndex</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>valueIndex</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>processFile()</code> function does all the work, and that makes it easy for us to write a benchmark.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Benchmark_processFile</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>processFile</span>(<span style=color:#e6db74>&#34;../ngrams.tsv&#34;</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=results class=anchor-link><a href=#results>Results</a></h2><p>The first version works, but it&rsquo;s not very fast. We can see its performance by running <code>go test -cpuprofile cpu.prof -memprofile mem.prof -bench .</code> both to get a benchmark, and to see which parts are slow.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>max_key: <span style=color:#ae81ff>2006</span> sum: <span style=color:#ae81ff>22569013</span>
</span></span><span style=display:flex><span>Benchmark_processFile-4   	       1	<span style=color:#ae81ff>3486100959</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok  	github.com/adamdrake/faster-command-line-tools-in-nim/Go/v1	3.491s
</span></span></code></pre></div><p>Our first version takes about 3.49 seconds to run, which isn&rsquo;t bad, but isn&rsquo;t great. Why so slow? Let&rsquo;s <code>go tool pprof cpu.prof</code> and find out.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Entering interactive mode <span style=color:#f92672>(</span>type <span style=color:#e6db74>&#34;help&#34;</span> <span style=color:#66d9ef>for</span> commands<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>pprof<span style=color:#f92672>)</span> text
</span></span><span style=display:flex><span>2250ms of 3490ms total <span style=color:#f92672>(</span>64.47%<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Dropped <span style=color:#ae81ff>33</span> nodes <span style=color:#f92672>(</span>cum &lt;<span style=color:#f92672>=</span> 17.45ms<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Showing top <span style=color:#ae81ff>10</span> nodes out of <span style=color:#ae81ff>65</span> <span style=color:#f92672>(</span>cum &gt;<span style=color:#f92672>=</span> 160ms<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      flat  flat%   sum%        cum   cum%
</span></span><span style=display:flex><span>     600ms 17.19% 17.19%     1530ms 43.84%  strings.genSplit
</span></span><span style=display:flex><span>     330ms  9.46% 26.65%      790ms 22.64%  runtime.mallocgc
</span></span><span style=display:flex><span>     260ms  7.45% 34.10%      260ms  7.45%  runtime.heapBitsSetType
</span></span><span style=display:flex><span>     200ms  5.73% 39.83%      200ms  5.73%  runtime.indexbytebody
</span></span><span style=display:flex><span>     200ms  5.73% 45.56%      310ms  8.88%  runtime.mapaccess1_faststr
</span></span><span style=display:flex><span>     170ms  4.87% 50.43%      410ms 11.75%  runtime.mapassign
</span></span><span style=display:flex><span>     160ms  4.58% 55.01%      160ms  4.58%  runtime.aeshashbody
</span></span><span style=display:flex><span>     120ms  3.44% 58.45%      400ms 11.46%  strings.Count
</span></span><span style=display:flex><span>     110ms  3.15% 61.60%     3440ms 98.57%  github.com/adamdrake/faster-command-line-tools-in-nim/Go/v1.processFile
</span></span><span style=display:flex><span>     100ms  2.87% 64.47%      160ms  4.58%  strconv.ParseInt
</span></span></code></pre></div><p>It seems like we spend a lot of time on <code>genSplit()</code>, which is the General Split command invoked by <code>strings.Split()</code> in our code. To see this, we can type <code>list processFile</code> in <code>pprof</code> to get the line-by-line timing for that function. Here&rsquo;s a selection of the output of <code>list processFile</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>         .      240ms     29:	<span style=color:#66d9ef>for</span> fileReader.Scan<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         .      2.19s     30:		fields :<span style=color:#f92672>=</span> strings.Split<span style=color:#f92672>(</span>strings.TrimSpace<span style=color:#f92672>(</span>fileReader.Text<span style=color:#f92672>())</span>, delim<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         .          .     31:
</span></span><span style=display:flex><span>         .          .     32:		<span style=color:#66d9ef>if</span> maxFieldIndex &lt; len<span style=color:#f92672>(</span>fields<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      10ms      190ms     33:			value, err :<span style=color:#f92672>=</span> strconv.Atoi<span style=color:#f92672>(</span>fields<span style=color:#f92672>[</span>valueIndex<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>         .          .     34:			<span style=color:#66d9ef>if</span> err !<span style=color:#f92672>=</span> nil <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         .          .     35:				log.Fatal<span style=color:#f92672>(</span>err<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         .          .     36:			<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>      80ms      800ms     37:			sumByKey<span style=color:#f92672>[</span>fields<span style=color:#f92672>[</span>keyIndex<span style=color:#f92672>]]</span> +<span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>         .          .     38:		<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>         .          .     39:	<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>We see that out of the 3.49s we&rsquo;re spending processing our file, 2.19s of that is spent just splitting strings. To confirm that <code>genSplit()</code> is in <code>strings.Split()</code> we can do the same thing with <code>list Split</code> and get all the details on where the time is going.</p><p>Let&rsquo;s assume that we aren&rsquo;t going to dive in and start making changes to the standard library. What should we do to improve the speed? The natural thing for most Go programmers is to turn to channels and goroutines. Spoiler alert: that is slower.</p><h1 id=v2-channels-and-goroutines class=anchor-link><a href=#v2-channels-and-goroutines>V2: Channels and Goroutines</a></h1><p>Channels and goroutines are great, but often overused. They have a startup cost, and many people are not aware of the fact that channels are a data structure that includes a mutex, and therefore subject to lock contention (i.e., they can be slow). Regardless, let&rsquo;s see how the performance fares if we go that route. We&rsquo;ll keep the map and other data in a <code>struct</code>, which we&rsquo;ll protect with a <code>sync.Mutex</code> so that we have thread-safe write access to the map (recall: in Go, a <code>map</code> is <strong>NOT</strong> thread-safe).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;flag&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;math&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;strconv&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fstream</span> <span style=color:#e6db74>&#34;github.com/adamdrake/gofstream&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>kv</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>keyIndex</span>, <span style=color:#a6e22e>valueIndex</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>store</span>                <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>rows</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>data</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>kv</span>, <span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>keyIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>keyIndex</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>valueIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>valueIndex</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>maxFieldIndex</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Max</span>(float64(<span style=color:#a6e22e>keyIndex</span>), float64(<span style=color:#a6e22e>valueIndex</span>)))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sumByKey</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>rows</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fields</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>TrimSpace</span>(<span style=color:#a6e22e>r</span>), <span style=color:#e6db74>&#34;\t&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>maxFieldIndex</span> &lt; len(<span style=color:#a6e22e>fields</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Atoi</span>(<span style=color:#a6e22e>fields</span>[<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>valueIndex</span>])
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>sumByKey</span>[<span style=color:#a6e22e>fields</span>[<span style=color:#a6e22e>keyIndex</span>]] <span style=color:#f92672>+=</span> <span style=color:#a6e22e>value</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>sumByKey</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>store</span>[<span style=color:#a6e22e>k</span>] <span style=color:#f92672>+=</span> <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>processFile</span>(<span style=color:#a6e22e>filePath</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>keyIndex</span>, <span style=color:#a6e22e>valueIndex</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rows</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fstream</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>filePath</span>, <span style=color:#ae81ff>100000</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>kv</span>{<span style=color:#a6e22e>keyIndex</span>: <span style=color:#a6e22e>keyIndex</span>, <span style=color:#a6e22e>valueIndex</span>: <span style=color:#a6e22e>valueIndex</span>, <span style=color:#a6e22e>store</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>4</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>rows</span>, <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>wg</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>maxValue</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>maxKey</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>store</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> &gt; <span style=color:#a6e22e>maxValue</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>maxValue</span> = <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>maxKey</span> = <span style=color:#a6e22e>k</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;max_key:&#34;</span>, <span style=color:#a6e22e>maxKey</span>, <span style=color:#e6db74>&#34;sum:&#34;</span>, <span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>store</span>[<span style=color:#a6e22e>maxKey</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>filePath</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;filePath&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;Name of the file to parse&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>keyIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>Int</span>(<span style=color:#e6db74>&#34;keyIndex&#34;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Index of key (0 is first position)&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>valueIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>Int</span>(<span style=color:#e6db74>&#34;valueIndex&#34;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Index of value (0 is first position)&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>Parse</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>processFile</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>filePath</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>keyIndex</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>valueIndex</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code has the same <code>processFile()</code> function as before, but this time it creates a streaming reader for the file, and streams each row of the file over a channel. We then give the channel to a worker thread, and the workers do the same thing we did before. We also have some additional complexity in the form of a <code>sync.WaitGroup</code> to make sure we actually wait and allow the workers to do their job before <code>main()</code> returns. What&rsquo;s the performance? Not great. In fact, it&rsquo;s worse, at about 4.5s.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>max_key: <span style=color:#ae81ff>2006</span> sum: <span style=color:#ae81ff>22569013</span>
</span></span><span style=display:flex><span>Benchmark_processFile-4   	       1	<span style=color:#ae81ff>4476065569</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok  	github.com/adamdrake/faster-command-line-tools-in-nim/Go/v4	4.482s
</span></span></code></pre></div><p>I won&rsquo;t go into the <code>pprof</code> output for this one, but you can see that the reason it&rsquo;s slower is because of <code>runtime.procyield</code>, due to all our goroutines. I probably could have tried to do some things with <code>sync/atomic</code> instead of using a mutex on the struct, but spinning up goroutines for such a small file doesn&rsquo;t make much sense in this case anyway. If the file was larger, perhaps we&rsquo;d get the benefit of using all cores, but for input of this size it just isn&rsquo;t worth it.</p><h1 id=v4-stop-using-strings class=anchor-link><a href=#v4-stop-using-strings>V4: Stop using strings</a></h1><p>Since it seems that a lot of the overhead is in parsing and splitting strings, why not just operate on the underlying bytes instead? Credit to valyala for <a href=https://www.reddit.com/r/golang/comments/6dhbwv/faster_command_line_tools_in_golang/di3wo37/>their version</a>, which reads and splits on <code>bytes</code> instead of <code>string</code>. Here&rsquo;s my version of their code, with an additional twist from a <a href=https://stackoverflow.com/a/27217267>Stack Overflow post</a> which allows us to use a faster string to integer parsing method, assuming that the input values we are summing are always positive integers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;bufio&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;bytes&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;errors&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>processFile</span>(<span style=color:#a6e22e>file</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>File</span>, <span style=color:#a6e22e>keyField</span>, <span style=color:#a6e22e>valueField</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sumByKey</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>maxField</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>keyField</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>valueField</span> &gt; <span style=color:#a6e22e>maxField</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>maxField</span> = <span style=color:#a6e22e>valueField</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanner</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewScanner</span>(<span style=color:#a6e22e>file</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Scan</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>line</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Bytes</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getKeyVal</span>(<span style=color:#a6e22e>line</span>, <span style=color:#a6e22e>keyField</span>, <span style=color:#a6e22e>valueField</span>, <span style=color:#a6e22e>maxField</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumByKey</span>[<span style=color:#a6e22e>key</span>] <span style=color:#f92672>+=</span> <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>k</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>sumByKey</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>val</span> &gt; <span style=color:#a6e22e>v</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>key</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;max_key: %s sum: %d&#34;</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>keyField</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atoi</span>([]byte(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>2</span>]))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>valueField</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atoi</span>([]byte(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>3</span>]))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>processFile</span>(<span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>keyField</span>, <span style=color:#a6e22e>valueField</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getKeyVal</span>(<span style=color:#a6e22e>line</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>keyField</span>, <span style=color:#a6e22e>valueField</span>, <span style=color:#a6e22e>maxField</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>tabIndex</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>k</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>v</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>field</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>maxField</span> <span style=color:#f92672>&amp;&amp;</span> len(<span style=color:#a6e22e>line</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>tabIndex</span> = <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>IndexByte</span>(<span style=color:#a6e22e>line</span>, <span style=color:#e6db74>&#39;\t&#39;</span>) <span style=color:#75715e>// returns -1 if not found
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tabIndex</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>field</span> = <span style=color:#a6e22e>line</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>line</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>field</span> = <span style=color:#a6e22e>line</span>[:<span style=color:#a6e22e>tabIndex</span>]
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>line</span> = <span style=color:#a6e22e>line</span>[<span style=color:#a6e22e>tabIndex</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:]
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>i</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>keyField</span>:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>field</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>valueField</span>:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>field</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>val</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atoi</span>(<span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> string(<span style=color:#a6e22e>k</span>), <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>errAtoi</span> = <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;invalid number&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>atoi</span>(<span style=color:#a6e22e>input</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>input</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>char</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>input</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>char</span> &lt; <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>char</span> &gt; <span style=color:#e6db74>&#39;9&#39;</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>errAtoi</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>val</span> = <span style=color:#a6e22e>val</span><span style=color:#f92672>*</span><span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> int(<span style=color:#a6e22e>char</span>) <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>val</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, instead of reading in the line as a string and then splitting the string on the delimiter with <code>strings.Split()</code>, we&rsquo;re reading in the line as a bytestring, and using the <code>bytes.IndexByte()</code> function to find the index of the delimiter in the bytestring. We loop through the bytestring by finding the current delimiter (which corresponds to the command line arguments we received for key index and value index), and sum the values as always. How much do we save by operating on the bytes instead of the strings? A lot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>max_key: <span style=color:#ae81ff>2006</span> sum: <span style=color:#ae81ff>22569013</span>
</span></span><span style=display:flex><span>Benchmark_processFile-4   	       1	<span style=color:#ae81ff>1517321373</span> ns/op
</span></span><span style=display:flex><span>PASS
</span></span></code></pre></div><p>Great! This approach cut our runtime by about 60%, and it&rsquo;s still pretty usable as production code. It&rsquo;s not too customized, it still fits the requirements of the original problem definition of key column and value column being command line arguments, and it&rsquo;s pretty readable. Where is the time mostly spent?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>pprof<span style=color:#f92672>)</span> text
</span></span><span style=display:flex><span>1200ms of 1500ms total <span style=color:#f92672>(</span>80.00%<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Showing top <span style=color:#ae81ff>10</span> nodes out of <span style=color:#ae81ff>41</span> <span style=color:#f92672>(</span>cum &gt;<span style=color:#f92672>=</span> 50ms<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      flat  flat%   sum%        cum   cum%
</span></span><span style=display:flex><span>     260ms 17.33% 17.33%      670ms 44.67%  github.com/adamdrake/faster-command-line-tools-in-nim/Go/v5.getKeyVal
</span></span><span style=display:flex><span>     200ms 13.33% 30.67%      330ms 22.00%  runtime.mapaccess1_faststr
</span></span><span style=display:flex><span>     170ms 11.33% 42.00%      170ms 11.33%  runtime.indexbytebody
</span></span><span style=display:flex><span>     120ms  8.00% 50.00%      260ms 17.33%  runtime.mapassign
</span></span><span style=display:flex><span>     100ms  6.67% 56.67%      100ms  6.67%  runtime.aeshashbody
</span></span><span style=display:flex><span>      90ms  6.00% 62.67%      120ms  8.00%  runtime.mallocgc
</span></span><span style=display:flex><span>      70ms  4.67% 67.33%     1500ms   100%  github.com/adamdrake/faster-command-line-tools-in-nim/Go/v5.processFile
</span></span><span style=display:flex><span>      70ms  4.67% 72.00%       70ms  4.67%  runtime.memeqbody
</span></span><span style=display:flex><span>      70ms  4.67% 76.67%       80ms  5.33%  syscall.Syscall
</span></span><span style=display:flex><span>      50ms  3.33% 80.00%       50ms  3.33%  github.com/adamdrake/faster-command-line-tools-in-nim/Go/v5.atoi
</span></span></code></pre></div><p>Most of the time is spent splitting the bytes and getting the key/value pairs, as expected. Let&rsquo;s <code>list getKeyVal</code> to take a closer look.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>260ms      670ms <span style=color:#f92672>(</span>flat, cum<span style=color:#f92672>)</span> 44.67% of Total
</span></span><span style=display:flex><span>         .          .     51:	var tabIndex int
</span></span><span style=display:flex><span>         .          .     52:	var k <span style=color:#f92672>[]</span>byte
</span></span><span style=display:flex><span>         .          .     53:	var v <span style=color:#f92672>[]</span>byte
</span></span><span style=display:flex><span>         .          .     54:	var field <span style=color:#f92672>[]</span>byte
</span></span><span style=display:flex><span>         .          .     55:
</span></span><span style=display:flex><span>      20ms       20ms     56:	<span style=color:#66d9ef>for</span> i &lt;<span style=color:#f92672>=</span> maxField <span style=color:#f92672>&amp;&amp;</span> len<span style=color:#f92672>(</span>line<span style=color:#f92672>)</span> &gt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      20ms      160ms     57:		tabIndex <span style=color:#f92672>=</span> bytes.IndexByte<span style=color:#f92672>(</span>line, <span style=color:#e6db74>&#39;\t&#39;</span><span style=color:#f92672>)</span> // returns -1 <span style=color:#66d9ef>if</span> not found
</span></span><span style=display:flex><span>      20ms       20ms     58:		<span style=color:#66d9ef>if</span> tabIndex &lt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         .          .     59:			field <span style=color:#f92672>=</span> line
</span></span><span style=display:flex><span>         .          .     60:			line <span style=color:#f92672>=</span> nil
</span></span><span style=display:flex><span>         .          .     61:		<span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      10ms       10ms     62:			field <span style=color:#f92672>=</span> line<span style=color:#f92672>[</span>:tabIndex<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>      60ms       60ms     63:			line <span style=color:#f92672>=</span> line<span style=color:#f92672>[</span>tabIndex+1:<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>         .          .     64:		<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>         .          .     65:		switch i <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      10ms       10ms     66:		<span style=color:#66d9ef>case</span> keyField:
</span></span><span style=display:flex><span>         .          .     67:			k <span style=color:#f92672>=</span> field
</span></span><span style=display:flex><span>      10ms       10ms     68:		<span style=color:#66d9ef>case</span> valueField:
</span></span><span style=display:flex><span>         .          .     69:			v <span style=color:#f92672>=</span> field
</span></span><span style=display:flex><span>         .          .     70:		<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>      10ms       10ms     71:		i++
</span></span><span style=display:flex><span>         .          .     72:	<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>      40ms       90ms     73:	val, _ :<span style=color:#f92672>=</span> atoi<span style=color:#f92672>(</span>v<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      60ms      280ms     74:	<span style=color:#66d9ef>return</span> string<span style=color:#f92672>(</span>k<span style=color:#f92672>)</span>, val
</span></span><span style=display:flex><span>         .          .     75:<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>We can see that the most time is spent getting the index of the bytes, and some on string casting for the key (so that we can use it as the map key). In a practical scenario, we&rsquo;d probably stop here since, as mentioned above, this is probably about as fast as the code will get while still being sufficiently general, readable, etc. We can do better though, if we break the requirements of the original comparison.</p><h1 id=v5-lets-go-nuts class=anchor-link><a href=#v5-lets-go-nuts>V5: Let&rsquo;s go nuts</a></h1><p>Let&rsquo;s put some of the practical concerns aside for the moment and focus on what we know about the problem. First, we are trusting our input data, which we&rsquo;d normally be more careful about in a real-world situation. With that in mind, we can change the definitions of our <code>atoi()</code> function so that it doesn&rsquo;t do any error checking, and so that it only operates on <code>[]byte</code> and returns <code>int</code>. Here&rsquo;s what the simplified <code>atoi</code> looks like.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>atoi</span>(<span style=color:#a6e22e>s</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>s</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>x</span><span style=color:#f92672>*</span><span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> int(<span style=color:#a6e22e>c</span>) <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We also know that the keys and values are always integers, so we could use an <code>int</code> type instead of <code>string</code> in the map keys, and we could also remove the <code>string(k)</code> cast in the <code>getKeyVal()</code> implementation above. However, we know in this case that we want the value between the first and second separator, and between the second and third separator, every time. So in this contrived instance, we don&rsquo;t actually need to iterate and check delimiters. We can just treat the entire line like the bytestring it is, and only find the indexes for the first, second, and third instances of the delimiter.</p><p>Another important fact is that, for this dataset, we know the largest key. Therefore, instead of a map that we previously saw was costing us about 800ms to increment, we can use an array. In this case, our integer key will be the index, and the value at that index will be the sum for that key. With that in mind, we have a highly customised, but <strong>SUPER FAST</strong> version below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>processFile</span>(<span style=color:#a6e22e>file</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>processFile</span>(<span style=color:#a6e22e>file</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>File</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sumByKey</span> [<span style=color:#ae81ff>2009</span>]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanner</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewScanner</span>(<span style=color:#a6e22e>file</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Scan</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>line</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Bytes</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>firstTab</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>IndexByte</span>(<span style=color:#a6e22e>line</span>, <span style=color:#e6db74>&#39;\t&#39;</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>secondTab</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>IndexByte</span>(<span style=color:#a6e22e>line</span>[<span style=color:#a6e22e>firstTab</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:], <span style=color:#e6db74>&#39;\t&#39;</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>firstTab</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>thirdTab</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>IndexByte</span>(<span style=color:#a6e22e>line</span>[<span style=color:#a6e22e>secondTab</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:], <span style=color:#e6db74>&#39;\t&#39;</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>secondTab</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>key</span> = <span style=color:#a6e22e>atoi</span>(<span style=color:#a6e22e>line</span>[<span style=color:#a6e22e>firstTab</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> : <span style=color:#a6e22e>secondTab</span>])
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>val</span> = <span style=color:#a6e22e>atoi</span>(<span style=color:#a6e22e>line</span>[<span style=color:#a6e22e>secondTab</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> : <span style=color:#a6e22e>thirdTab</span>])
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumByKey</span>[<span style=color:#a6e22e>key</span>] <span style=color:#f92672>+=</span> <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>k</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>v</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>sumByKey</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>val</span> &gt; <span style=color:#a6e22e>v</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;max_key: %d sum: %d\n&#34;</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What&rsquo;s the <code>pprof</code> result?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Benchmark_processFile-4   	max_key: <span style=color:#ae81ff>2006</span> sum: <span style=color:#ae81ff>22569013</span>
</span></span><span style=display:flex><span>max_key: <span style=color:#ae81ff>2006</span> sum: <span style=color:#ae81ff>22569013</span>
</span></span><span style=display:flex><span>max_key: <span style=color:#ae81ff>2006</span> sum: <span style=color:#ae81ff>22569013</span>
</span></span><span style=display:flex><span>max_key: <span style=color:#ae81ff>2006</span> sum: <span style=color:#ae81ff>22569013</span>
</span></span><span style=display:flex><span>max_key: <span style=color:#ae81ff>2006</span> sum: <span style=color:#ae81ff>22569013</span>
</span></span><span style=display:flex><span>       3	 <span style=color:#ae81ff>482369483</span> ns/op
</span></span></code></pre></div><p>It&rsquo;s crazy fast! This version finishes in 0.482s (482ms) on my machine. Where is the most time spent now? (Note that because the benchmark ran multiple times in order to get a stable timing for the run, the <code>pprof</code> results are the sum of all the runs.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>      20ms      1.26s     38:	<span style=color:#66d9ef>for</span> scanner.Scan<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      70ms       70ms     39:		line :<span style=color:#f92672>=</span> scanner.Bytes<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>      40ms      200ms     40:		firstTab :<span style=color:#f92672>=</span> bytes.IndexByte<span style=color:#f92672>(</span>line, <span style=color:#e6db74>&#39;\t&#39;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>     190ms      330ms     41:		secondTab :<span style=color:#f92672>=</span> bytes.IndexByte<span style=color:#f92672>(</span>line<span style=color:#f92672>[</span>firstTab+1:<span style=color:#f92672>]</span>, <span style=color:#e6db74>&#39;\t&#39;</span><span style=color:#f92672>)</span> + firstTab + <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>     260ms      610ms     42:		thirdTab :<span style=color:#f92672>=</span> bytes.IndexByte<span style=color:#f92672>(</span>line<span style=color:#f92672>[</span>secondTab+1:<span style=color:#f92672>]</span>, <span style=color:#e6db74>&#39;\t&#39;</span><span style=color:#f92672>)</span> + secondTab + <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      80ms      160ms     43:		key <span style=color:#f92672>=</span> atoi<span style=color:#f92672>(</span>line<span style=color:#f92672>[</span>firstTab+1 : secondTab<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>      40ms      180ms     44:		val <span style=color:#f92672>=</span> atoi<span style=color:#f92672>(</span>line<span style=color:#f92672>[</span>secondTab+1 : thirdTab<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>      70ms       70ms     45:		sumByKey<span style=color:#f92672>[</span>key<span style=color:#f92672>]</span> +<span style=color:#f92672>=</span> val
</span></span><span style=display:flex><span>         .          .     46:	<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Most of the time is spent indexing into the bytestring, which is what we expected. There may be some clever ways to reduce this, in addition to some data structures which would allow us to do the incrementing faster, but at this point we&rsquo;re pretty far down the path of optimizing past production usage, and hand-tuned Fortran/assembly isn&rsquo;t really the goal. In the end though, we processed a 184MB file, with 10,512,769 rows, in 0.482s.</p><p>Happy optimizing!</p><h1 id=updated-code class=anchor-link><a href=#updated-code>Updated code:</a></h1><p>Since the article was posted on Reddit and Hackernews, there was a user (Epiris) on Reddit who suggested some improvements. After their suggestions, below is the code and benchmarks for the updated version. It&rsquo;s important to note that a personal requirement I have for the code is that it cannot read all data into memory, since we must assume that the data stream could be arbitrarily large.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>processLine</span>(<span style=color:#a6e22e>b</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\t&#39;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>; <span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\t&#39;</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>key</span> = <span style=color:#a6e22e>key</span><span style=color:#f92672>*</span><span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> int(<span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>i</span>]) <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>; <span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\t&#39;</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>val</span> = <span style=color:#a6e22e>val</span><span style=color:#f92672>*</span><span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> int(<span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>i</span>]) <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>processFile</span>(<span style=color:#a6e22e>file</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>File</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sumByKey</span> [<span style=color:#ae81ff>2009</span>]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanner</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewScanner</span>(<span style=color:#a6e22e>file</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Scan</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>line</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Bytes</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>k1</span>, <span style=color:#a6e22e>v1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>processLine</span>(<span style=color:#a6e22e>line</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sumByKey</span>[<span style=color:#a6e22e>k1</span>] <span style=color:#f92672>+=</span> <span style=color:#a6e22e>v1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>k</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>v</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>sumByKey</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>val</span> &gt; <span style=color:#a6e22e>v</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>val</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And here is the associated benchmark.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Benchmark_processFile</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;../ngrams.tsv&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>file</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ResetTimer</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>processFile</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2006</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>22569013</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>`bad result %v | %v`</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The output of the benchmarking:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Benchmark_processFile-4   	       5	 <span style=color:#ae81ff>309631168</span> ns/op	    <span style=color:#ae81ff>4152</span> B/op	       <span style=color:#ae81ff>4</span> allocs/op
</span></span></code></pre></div><a class=hidden href=https://brid.gy/publish/mastodon></a>
<a class=hidden href=https://brid.gy/publish/twitter></a>
<a class=hidden href=https://fed.brid.gy/></a>
<data class=p-bridgy-omit-link value=false></data></article></div><div id=webmentions></div></li></ul></section></main><hr><footer class="flex col"><section class="footer-bio content"><p><strong>Adam Drake</strong> leads technical business transformations in global and multi-cultural environments. He has a passion for helping companies become more productive by improving internal leadership capabilities, and accelerating product development through technology and data architecture guidance. Adam has served as a White House Presidential Innovation Fellow and is an IEEE Senior Member.</p></section><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button><div class=social-icons><a rel=me href=https://github.com/adamdrake title=GitHub><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a rel=me href=https://linkedin.com/in/aadrake title=LinkedIn><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a><a rel=me href=https://twitter.com/aadrake title=Twitter><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></footer></body></html>
<!doctype html><html lang=en><head><meta charset=utf-8><meta name=mobile-web-app-capable content="yes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Serverless with Lambda, API Gateway, and Go - Adam Drake</title><meta name=description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/crypto/data, leadership, and building tech teams."><link rel="shortcut icon" href=https://adamdrake.com/static/favicon.ico><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=me href=https://github.com/adamdrake><link rel=me href=https://twitter.com/aadrake><link rel=stylesheet href=https://adamdrake.com/css/style.min.css crossorigin=anonymous media=screen><meta property="og:url" content="https://adamdrake.com"><meta property="og:title" content="Adam Drake"><meta property="og:site_name" content="Adam Drake"><meta property="og:type" content="website"><meta property="og:description" content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/crypto/data, leadership, and building tech teams."><meta property="og:image" content="/static/images/twitter-card.jpg"><meta name=twitter:title content="Adam Drake"><meta name=twitter:description content="Adam Drake is an advisor to scale-up tech companies. He writes about ML/AI/crypto/data, leadership, and building tech teams."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/static/images/twitter-card.jpg"></head><body><header><section><div class="header flex row"><div class="header__item flex row"><a id=site__name href=https://adamdrake.com>Adam Drake</a></div><div class="flex row"><nav aria-label="page menu" class="flex row"><ul role=menubar class="flex row"><li role=none><a class=sidebar-nav-itemmenu__item href=/ title>Latest</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/about.html title>About</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/cases.html title>Case Studies</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/contact.html title>Contact</a></li><li role=none><a class="sidebar-nav-item activemenu__item" href=/posts.html title=Posts>Posts</a></li><li role=none><a class=sidebar-nav-itemmenu__item href=/press.html title>Press</a></li><li><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button></li></ul></nav></div></div></section></header><main aria-role=main><section><ul id=feed__ul><li class="feed__li h-entry"><div class=feed__content><time class="hidden dt-published">2018-02-11 00:00:00 +0000 UTC</time><div class="flex properties__row"><div rel=author class="flex left p-author h-card hidden"><img class=u-photo src=https://adamdrake.com/static/images/adam_drake_240.jpg alt="Adam Drake" id=author-img><div><p rel=me class=p-name id=author-name>Adam Drake</p><p class=properties>Feb 11, 2018</p></div></div><div class="flex right properties"></div></div><article class="md p-summary e-content"><h1 class=p-name>Serverless with Lambda, API Gateway, and Go</h1><h1 id=intro class=anchor-link><a href=#intro>Intro</a></h1><p>Some time ago I made <a href=https://tinysite.adamdrake.com>TinySite</a> and I wrote an article about building the <a href=/the-biggest-smallest-website.html>Biggest Smallest Website</a>. As part of that work, I also built <a href=https://compresstest.com>CompressTest</a> in order to provide some insight on size of data post-compression for a few of the compress methods in the Go standard library.</p><p>Those services were running on EC2 instances via Elastic Beanstalk, and while the cost wasn&rsquo;t great, I have other side projects which, like those, require few resources and therefore result in EC2 instances which are mostly idling. Ditto for the Elastic Load Balancers which are part and parcel of an Elastic Beanstalk setup. That money is wasted, and in the case of CompressTest, since it is CPU-intensive, I had to have the setup in Elastic Beanstalk such that it could auto-scale in the event that the site ends up on Hacker News or another aggregator which results in high traffic loads. What I wanted was a system that didn&rsquo;t really cost anything if it wasn&rsquo;t being used, but that could scale up at a moment&rsquo;s notice to whatever load happened to come in.</p><p>New serverless approaches, like AWS API Gateway and AWS Lambda, provide a cheap, fast-scaling option for a relatively low-traffic service without strict performance and latency requirements.</p><h1 id=elastic-beanstalk---old-and-busted class=anchor-link><a href=#elastic-beanstalk---old-and-busted>Elastic Beanstalk - Old and busted</a></h1><p>Elastic Beanstalk works great, but requires at least one Elastic Load Balancer and one EC2 instance to form a functioning environment. Additionally, scale-up time is determined by triggers that start or stop instances. This means that having additional capacity on hand might take five minutes for something like an average CPU usage alarm to trigger, and then another few minutes for instances to come online. If you need further instances, they will have to wait for the duration of whatever cool-down period you have configured (say three to five minutes), before initiating startup of additional instances. This may not be so bad for larger services where there are sustained requests over time and where the traffic scales up relatively smoothly throughout the day, but it&rsquo;s not great for traffic that could come in large bursts, as in the situation I want to address.</p><p>Elastic Beanstalk is also not great for side projects, since the minimum cost to have the infrastructure running is around $25 USD per month. This isn&rsquo;t going to break the bank for a single side project, but it does start to add up when you have many of them.</p><p>Considering the above, you might wonder about abstracting the load balancers and servers away entirely, and worry only about executing functions in your application. Enter AWS API Gateway and Lambda.</p><h1 id=serverless---new-hotness class=anchor-link><a href=#serverless---new-hotness>Serverless - New Hotness</a></h1><p>Serverless has been a thing for a few years, but most of the systems I work with are high-performance (making it too expensive) and low latency (making it impossible to use due to calling overhead). Those two points, combined with vendor lock-in issues, are why I typically don&rsquo;t recommend the serverless approach for my advising clients. However, in this case it makes a lot of sense. You only pay for what you use, and there isn&rsquo;t really any such thing as idling servers because there are no servers (from a billing and administration standpoint). You pay for API Gateway on a per-request basis, and Lambda on a per-invocation basis, so the unused capacity problem goes away.</p><p>Requests to the API first hit API Gateway, which proxies requests to other systems - in this case, a function running on AWS Lambda. Lambda handles execution and scaling and, as long as each request doesn&rsquo;t run for too long, it ends up being far cheaper than having instance(s) that idle for most of the time. Currently, everyone is eligible for the free tier of Lambda, regardless of how long you&rsquo;ve been an AWS customer. The free tier gets you one million function invocations per month. API Gateway costs $3.50 per million function calls, plus data transfer costs (in this case, they&rsquo;re effectively zero). In other words, instead of having a nano EC2 instance running TinySite (for roughly $5 per month) and an EB environment for CompressTest (for $25 per month), plus other instances for my other projects, I can run all the same services for pretty close to free.</p><h2 id=api-gateway class=anchor-link><a href=#api-gateway>API Gateway</a></h2><p>API Gateway has a small cost, but as mentioned it&rsquo;s only $3.50 per million API requests. For a side project like this, getting multiple millions of API requests per month is unlikely, so $3.50 is a reasonable approximation of the total cost.</p><p>In the case of CompressTest, I set up a <code>POST</code> endpoint on API Gateway which forwards the requests to a Lambda function. The Lambda function processes the request and responds to API Gateway, which then passes the response back to the user. There&rsquo;s a slight complication: in my testing, using API Gateway with Lambda means that even if you set up CORS headers on API Gateway, they will not be included in any response. Therefore, if you need CORS headers, make sure you set them in the response your function sends back to API Gateway. API Gateway will use whatever headers you set, with the exception of some reserved headers. I create the response object and set the headers immediately just to be on the safe side:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>compressHandler</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>request</span> <span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>APIGatewayProxyRequest</span>) (<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>APIGatewayProxyResponse</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Let&#39;s create the response we&#39;ll eventually send, being sure to have CORS headers in place
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>resp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>APIGatewayProxyResponse</span>{<span style=color:#a6e22e>Headers</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>)}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Headers</span>[<span style=color:#e6db74>&#34;Access-Control-Allow-Origin&#34;</span>] = <span style=color:#e6db74>&#34;*&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Remainder of the handler below...
</span></span></span></code></pre></div><p>Another complication is that API Gateway likes to assume everything is JSON, and neither CompressTest nor TinySite deal strictly with JSON or even UTF-8 data. CompressTest receives <code>multipart/form-data</code>, and TinySite responds with compressed data, which may contain arbitrary bytes. AWS API Gateway can handle binary media types as long as you set the Content-Type values in the settings for the endpoint, but I found it to be difficult/unreliable. The basic flow is that API Gateway receives the request and base64 encodes it. It then passes the request on to the Lambda function, which decodes it back to bytes to perform the operations defined in the handler. The resulting response is sent as-is if possible, or if it contains binary data it is base64 encoded before being sent to API Gateway. If the Content-Type header supplied by the Lambda function matches that which was specified in the settings in API Gateway, then API Gateway will base64 decode the response body before forwarding it on to the client. Additionally, I used the command line utility to set the <code>CONVERT_TO_BINARY</code> flag on egress as part of the process of trying to get it working.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>aws apigateway update-integration-response <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--rest-api-id XXXXXX <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--resource-id XXXXXX <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--http-method GET <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--status-code <span style=color:#ae81ff>200</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--patch-operations <span style=color:#e6db74>&#39;[{&#34;op&#34; : &#34;replace&#34;, &#34;path&#34; : &#34;/contentHandling&#34;, &#34;value&#34; : &#34;CONVERT_TO_BINARY&#34;}]&#39;</span>
</span></span></code></pre></div><p>In the end, it all works, but it wasn&rsquo;t trivial to set up since there are so many knobs to turn. I&rsquo;m not sure why API Gateway requires a string response instead of just bytes, but oh well. Lastly, it does not seem to be totally clear which changes to API Gateway require the API to be redeployed, and which take effect without redeployment. When in doubt, redeploy the API.</p><h2 id=lambda class=anchor-link><a href=#lambda>Lambda</a></h2><p>This part wasn&rsquo;t very difficult in either case. In the case of Go and receiving events from API Gateway, you are receiving an <code>APIGatewayProxyRequest</code> with a structure like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// APIGatewayProxyRequest contains data coming from the API Gateway proxy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>APIGatewayProxyRequest</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Resource</span>              <span style=color:#66d9ef>string</span>                        <span style=color:#e6db74>`json:&#34;resource&#34;`</span> <span style=color:#75715e>// The resource path defined in API Gateway
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Path</span>                  <span style=color:#66d9ef>string</span>                        <span style=color:#e6db74>`json:&#34;path&#34;`</span>     <span style=color:#75715e>// The url path for the caller
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>HTTPMethod</span>            <span style=color:#66d9ef>string</span>                        <span style=color:#e6db74>`json:&#34;httpMethod&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Headers</span>               <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>             <span style=color:#e6db74>`json:&#34;headers&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>QueryStringParameters</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>             <span style=color:#e6db74>`json:&#34;queryStringParameters&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>PathParameters</span>        <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>             <span style=color:#e6db74>`json:&#34;pathParameters&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>StageVariables</span>        <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>             <span style=color:#e6db74>`json:&#34;stageVariables&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>RequestContext</span>        <span style=color:#a6e22e>APIGatewayProxyRequestContext</span> <span style=color:#e6db74>`json:&#34;requestContext&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Body</span>                  <span style=color:#66d9ef>string</span>                        <span style=color:#e6db74>`json:&#34;body&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>IsBase64Encoded</span>       <span style=color:#66d9ef>bool</span>                          <span style=color:#e6db74>`json:&#34;isBase64Encoded,omitempty&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and you construct an <code>APIGatewayProxyResponse</code> which looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// APIGatewayProxyResponse configures the response to be returned by API Gateway for the request
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>APIGatewayProxyResponse</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>StatusCode</span>      <span style=color:#66d9ef>int</span>               <span style=color:#e6db74>`json:&#34;statusCode&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Headers</span>         <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;headers&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Body</span>            <span style=color:#66d9ef>string</span>            <span style=color:#e6db74>`json:&#34;body&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>IsBase64Encoded</span> <span style=color:#66d9ef>bool</span>              <span style=color:#e6db74>`json:&#34;isBase64Encoded,omitempty&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>IsBase64Encoded</code> field is used to differentiate between string data and raw bytes (compressed things, images, etc.) which have been base64 encoded, as mentioned in the section on API Gateway.</p><p>For CompressTest I just used the <code>APIGatewayProxyRequest</code> to build a <code>net/http.Request</code>, and then I used all the same code I had for the HTTP handler before.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>compressHandler</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>request</span> <span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>APIGatewayProxyRequest</span>) (<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>APIGatewayProxyResponse</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Let&#39;s create the response we&#39;ll eventually send, being sure to have CORS headers in place
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>resp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>APIGatewayProxyResponse</span>{<span style=color:#a6e22e>Headers</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>)}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Headers</span>[<span style=color:#e6db74>&#34;Access-Control-Allow-Origin&#34;</span>] = <span style=color:#e6db74>&#34;*&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Header</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>][]<span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>Headers</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;content-type&#34;</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Content-Type&#34;</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Header</span>.<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// NOTE: API Gateway is set up with */* as binary media type, so all APIGatewayProxyRequests will be base64 encoded
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>body</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>base64</span>.<span style=color:#a6e22e>StdEncoding</span>.<span style=color:#a6e22e>DecodeString</span>(<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>Body</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Body</span> = <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>NopCloser</span>(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewBuffer</span>(<span style=color:#a6e22e>body</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>StatusCode</span> = <span style=color:#ae81ff>403</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Body</span> = <span style=color:#e6db74>&#34;Could not read request body&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resp</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>ParseMultipartForm</span>(<span style=color:#a6e22e>maxRequestBodySize</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Handling the request continues...
</span></span></span></code></pre></div><p>Instead of taking an <code>http.Request</code> and an <code>http.ResponseWriter</code> I just take the context and <code>APIGatewayProxyRequest</code> and return the relevant <code>APIGatewayProxyResponse</code>. The other trick is setting the body, which for an HTTP Request requires a <code>Close()</code> method. However, if you try to <code>.Close()</code> in Lambda you&rsquo;ll get a nil pointer exception, since there isn&rsquo;t really an HTTP request there. Therefore, use the <code>ioutil.NopCloser</code> to wrap the reader, thus satisfying the <code>ReadCloser</code> interface expected on the <code>net/http</code> side when the form is parsed.</p><p>Also note how the Content-Type header is being set. Firefox will send the lower case version, and some tools like curl will send the title-case version, so it&rsquo;s important to check both cases. I probably could have also hard-coded this to <code>multipart/form-data</code> but in addition to being poor form it would also result in the boundary separator not being known, since it is specified in that header. This would result in the body of the HTTP request being impossible (or at least unreasonably difficult) to process.</p><p>Because CompressTest receives binary data, API Gateway will, as mentioned, forward the request body to our Lambda function after base64 encoding it. Therefore, we have to decode it first, and then process the request as normal.</p><p>In the case of TinySite, the only real change required was to set the <code>IsBase64Encoded</code> flag in the response. In fact, the whole handler for TinySite is only a few lines of code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>tinysite</span>() (<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>APIGatewayProxyResponse</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>buf</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>zw</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flate</span>.<span style=color:#a6e22e>NewWriter</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>flate</span>.<span style=color:#a6e22e>BestCompression</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>zw</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#a6e22e>resp</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>zw</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>compressedBody</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>Next</span>(<span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>Len</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>resp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>APIGatewayProxyResponse</span>{<span style=color:#a6e22e>StatusCode</span>: <span style=color:#ae81ff>200</span>, <span style=color:#a6e22e>Body</span>: <span style=color:#a6e22e>base64</span>.<span style=color:#a6e22e>StdEncoding</span>.<span style=color:#a6e22e>EncodeToString</span>(<span style=color:#a6e22e>compressedBody</span>), <span style=color:#a6e22e>IsBase64Encoded</span>: <span style=color:#66d9ef>true</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Headers</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Headers</span>[<span style=color:#e6db74>&#34;Content-Type&#34;</span>] = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>resp</span>.<span style=color:#a6e22e>Headers</span>[<span style=color:#e6db74>&#34;Content-Encoding&#34;</span>] = <span style=color:#e6db74>&#34;deflate&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resp</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note as well that if the <code>Content-Type</code> header is not set, then API Gateway will automatically set it to <code>application/json</code>, which we do not want. The content type is inferred by the client in this case, and it is not required in the HTTP spec to send <code>text/html</code> as one might suspect. By sending an empty string as the <code>Content-Type</code> we can ensure that it is not set by API Gateway. Note that this does not work with all headers, for example the custom Amazon headers prefixed with <code>x-</code> for tracing and other diagnostics will remain and if you try to set them to empty strings they will be copied and the generated headers inserted.</p><h1 id=summary class=anchor-link><a href=#summary>Summary</a></h1><p>With the exception of handling binary media types and making sure to use an <code>ioutil.NopCloser</code>, the whole process was pretty straightforward. While this approach is not appropriate for systems that need optimal performance or where latency constraints are tight, it may be ideal for some for some simpler projects. If you have relatively low-traffic sites that may need to scale to higher traffic volumes, and for which some request latency (e.g. 100-300ms) is tolerable, then this combination of API Gateway and Lambda may be a perfect fit.</p><a class=hidden href=https://brid.gy/publish/mastodon></a>
<a class=hidden href=https://brid.gy/publish/twitter></a>
<a class=hidden href=https://fed.brid.gy/></a>
<data class=p-bridgy-omit-link value=false></data></article></div><div id=webmentions></div></li></ul></section></main><hr><footer class="flex col"><section class="footer-bio content"><p><strong>Adam Drake</strong> leads technical business transformations in global and multi-cultural environments. He has a passion for helping companies become more productive by improving internal leadership capabilities, and accelerating product development through technology and data architecture guidance. Adam has served as a White House Presidential Innovation Fellow and is an IEEE Senior Member.</p></section><button class="subscribe subscribe-btn">
<a href=https://www.digitalmaneuver.com/#/portal>Subscribe to newsletter</a></button><div class=social-icons><a rel=me href=https://github.com/adamdrake title=GitHub><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a rel=me href=https://linkedin.com/in/aadrake title=LinkedIn><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a><a rel=me href=https://twitter.com/aadrake title=Twitter><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></footer></body></html>